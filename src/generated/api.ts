/* tslint:disable */
/* eslint-disable */
/**
 * Carthage API
 * The API Specification for Carthage
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface LogManagementCollect
 */
export interface LogManagementCollect {
    [key: string]: any;

    /**
     * 
     * @type {Array<LogManagementCollectRequestCollectLogsInner>}
     * @memberof LogManagementCollect
     */
    'collect_logs': Array<LogManagementCollectRequestCollectLogsInner>;
}
/**
 * 
 * @export
 * @interface LogManagementCollectRequest
 */
export interface LogManagementCollectRequest {
    [key: string]: any;

    /**
     * 
     * @type {Array<LogManagementCollectRequestCollectLogsInner>}
     * @memberof LogManagementCollectRequest
     */
    'collect_logs': Array<LogManagementCollectRequestCollectLogsInner>;
}
/**
 * 
 * @export
 * @interface LogManagementCollectRequestCollectLogsInner
 */
export interface LogManagementCollectRequestCollectLogsInner {
    /**
     * 
     * @type {LogManagementCollectRequestCollectLogsInnerLog}
     * @memberof LogManagementCollectRequestCollectLogsInner
     */
    'log': LogManagementCollectRequestCollectLogsInnerLog;
    /**
     * 
     * @type {Array<LogManagementCollectRequestCollectLogsInnerEntriesInner>}
     * @memberof LogManagementCollectRequestCollectLogsInner
     */
    'entries': Array<LogManagementCollectRequestCollectLogsInnerEntriesInner>;
}
/**
 * 
 * @export
 * @interface LogManagementCollectRequestCollectLogsInnerEntriesInner
 */
export interface LogManagementCollectRequestCollectLogsInnerEntriesInner {
    /**
     * The source of the entry, indicating what part of the system the entry is from.
     * @type {string}
     * @memberof LogManagementCollectRequestCollectLogsInnerEntriesInner
     */
    'source': string;
    /**
     * The context of the entry, providing additional information to help understand the entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementCollectRequestCollectLogsInnerEntriesInner
     */
    'context': { [key: string]: any; };
    /**
     * The attributes of the entry, providing additional information not included in the main message.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementCollectRequestCollectLogsInnerEntriesInner
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LogManagementCollectRequestCollectLogsInnerEntriesInner
     */
    'tags': Array<string>;
    /**
     * The timestamp indicating when the entry occurred.
     * @type {string}
     * @memberof LogManagementCollectRequestCollectLogsInnerEntriesInner
     */
    'occurred_at': string;
}
/**
 * 
 * @export
 * @interface LogManagementCollectRequestCollectLogsInnerLog
 */
export interface LogManagementCollectRequestCollectLogsInnerLog {
    /**
     * The namespace associated with the log.
     * @type {string}
     * @memberof LogManagementCollectRequestCollectLogsInnerLog
     */
    'namespace': string;
    /**
     * The severity level of the log.
     * @type {number}
     * @memberof LogManagementCollectRequestCollectLogsInnerLog
     */
    'level': LogManagementCollectRequestCollectLogsInnerLogLevelEnum;
    /**
     * The template used for formatting the log message.
     * @type {string}
     * @memberof LogManagementCollectRequestCollectLogsInnerLog
     */
    'template': string;
}

export const LogManagementCollectRequestCollectLogsInnerLogLevelEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementCollectRequestCollectLogsInnerLogLevelEnum = typeof LogManagementCollectRequestCollectLogsInnerLogLevelEnum[keyof typeof LogManagementCollectRequestCollectLogsInnerLogLevelEnum];

/**
 * 
 * @export
 * @interface LogManagementCreateLogEntryRequest
 */
export interface LogManagementCreateLogEntryRequest {
    /**
     * The identity of the associated log.
     * @type {string}
     * @memberof LogManagementCreateLogEntryRequest
     */
    'log_identity': string;
    /**
     * The source of the entry, indicating what part of the system the entry is from.
     * @type {string}
     * @memberof LogManagementCreateLogEntryRequest
     */
    'source': string;
    /**
     * The context of the entry, providing additional information to help understand the entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementCreateLogEntryRequest
     */
    'context': { [key: string]: any; };
    /**
     * The attributes of the entry, providing additional information not included in the main message.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementCreateLogEntryRequest
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LogManagementCreateLogEntryRequest
     */
    'tags': Array<string>;
    /**
     * The timestamp indicating when the entry occurred.
     * @type {string}
     * @memberof LogManagementCreateLogEntryRequest
     */
    'occurred_at': string;
}
/**
 * Paginated collection of LogResource.
 * @export
 * @interface LogManagementGetLogCollection200Response
 */
export interface LogManagementGetLogCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogCollection200Response
     */
    'type': LogManagementGetLogCollection200ResponseTypeEnum;
    /**
     * Current page number.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'page': number;
    /**
     * Number of items per page.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'items_per_page': number;
    /**
     * Total number of items.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'total_items': number;
    /**
     * First item index.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'first': number;
    /**
     * Last item index.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'last': number;
    /**
     * Next page number, if available.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'next'?: number | null;
    /**
     * Previous page number, if available.
     * @type {number}
     * @memberof LogManagementGetLogCollection200Response
     */
    'previous'?: number | null;
    /**
     * Array of LogResource.
     * @type {Array<LogManagementGetLogCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogCollection200Response
     */
    'items': Array<LogManagementGetLogCollection200ResponseItemsInner>;
}

export const LogManagementGetLogCollection200ResponseTypeEnum = {
    PaginatedCollection: 'paginated_collection'
} as const;

export type LogManagementGetLogCollection200ResponseTypeEnum = typeof LogManagementGetLogCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogCollection200ResponseTypeEnum];

/**
 * Resource representing a log.
 * @export
 * @interface LogManagementGetLogCollection200ResponseItemsInner
 */
export interface LogManagementGetLogCollection200ResponseItemsInner {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogCollection200ResponseItemsInnerTypeEnum;
    /**
     * Unique identity of the log.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'identity': string;
    /**
     * The namespace of the log.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'namespace': string;
    /**
     * 
     * @type {LogManagementGetLogCollection200ResponseItemsInnerLevel}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'level': LogManagementGetLogCollection200ResponseItemsInnerLevel;
    /**
     * The template for formatting the message.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'template': string;
    /**
     * Timestamp of the first entry occurrence, if available.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'first_entry_occurred_at'?: string | null;
    /**
     * Timestamp of the last entry occurrence, if available.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'last_entry_occurred_at'?: string | null;
    /**
     * Timestamp when the log was created.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'created_at': string;
    /**
     * Timestamp when the log was last updated.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInner
     */
    'updated_at': string;
}

export const LogManagementGetLogCollection200ResponseItemsInnerTypeEnum = {
    Log: 'log'
} as const;

export type LogManagementGetLogCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogCollection200ResponseItemsInnerTypeEnum];

/**
 * The log level.
 * @export
 * @interface LogManagementGetLogCollection200ResponseItemsInnerLevel
 */
export interface LogManagementGetLogCollection200ResponseItemsInnerLevel {
    /**
     * Name of the log level.
     * @type {string}
     * @memberof LogManagementGetLogCollection200ResponseItemsInnerLevel
     */
    'name': LogManagementGetLogCollection200ResponseItemsInnerLevelNameEnum;
    /**
     * Value of the log level.
     * @type {number}
     * @memberof LogManagementGetLogCollection200ResponseItemsInnerLevel
     */
    'value': LogManagementGetLogCollection200ResponseItemsInnerLevelValueEnum;
}

export const LogManagementGetLogCollection200ResponseItemsInnerLevelNameEnum = {
    Debug: 'Debug',
    Info: 'Info',
    Notice: 'Notice',
    Warning: 'Warning',
    Error: 'Error',
    Critical: 'Critical',
    Alert: 'Alert',
    Emergency: 'Emergency'
} as const;

export type LogManagementGetLogCollection200ResponseItemsInnerLevelNameEnum = typeof LogManagementGetLogCollection200ResponseItemsInnerLevelNameEnum[keyof typeof LogManagementGetLogCollection200ResponseItemsInnerLevelNameEnum];
export const LogManagementGetLogCollection200ResponseItemsInnerLevelValueEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementGetLogCollection200ResponseItemsInnerLevelValueEnum = typeof LogManagementGetLogCollection200ResponseItemsInnerLevelValueEnum[keyof typeof LogManagementGetLogCollection200ResponseItemsInnerLevelValueEnum];

/**
 * Paginated collection of LogEntryResource.
 * @export
 * @interface LogManagementGetLogEntryCollection200Response
 */
export interface LogManagementGetLogEntryCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'type': LogManagementGetLogEntryCollection200ResponseTypeEnum;
    /**
     * Current page number.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'page': number;
    /**
     * Number of items per page.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'items_per_page': number;
    /**
     * Total number of items.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'total_items': number;
    /**
     * First item index.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'first': number;
    /**
     * Last item index.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'last': number;
    /**
     * Next page number, if available.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'next'?: number | null;
    /**
     * Previous page number, if available.
     * @type {number}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'previous'?: number | null;
    /**
     * Array of LogEntryResource.
     * @type {Array<LogManagementGetLogEntryCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogEntryCollection200Response
     */
    'items': Array<LogManagementGetLogEntryCollection200ResponseItemsInner>;
}

export const LogManagementGetLogEntryCollection200ResponseTypeEnum = {
    PaginatedCollection: 'paginated_collection'
} as const;

export type LogManagementGetLogEntryCollection200ResponseTypeEnum = typeof LogManagementGetLogEntryCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogEntryCollection200ResponseTypeEnum];

/**
 * Resource representing a log entry.
 * @export
 * @interface LogManagementGetLogEntryCollection200ResponseItemsInner
 */
export interface LogManagementGetLogEntryCollection200ResponseItemsInner {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogEntryCollection200ResponseItemsInnerTypeEnum;
    /**
     * Unique identity of the log entry.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'identity': string;
    /**
     * Identity of the associated log.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'log_identity': string;
    /**
     * Source of the log entry.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'source': string;
    /**
     * Contextual information for the log entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'context': { [key: string]: any; };
    /**
     * Attributes associated with the log entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'attributes': { [key: string]: any; };
    /**
     * Tags associated with the log entry.
     * @type {Array<string>}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'tags': Array<string>;
    /**
     * Timestamp when the log entry occurred.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'occurred_at': string;
    /**
     * Timestamp when the log entry was created.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'created_at': string;
    /**
     * Timestamp when the log entry was last updated.
     * @type {string}
     * @memberof LogManagementGetLogEntryCollection200ResponseItemsInner
     */
    'updated_at': string;
}

export const LogManagementGetLogEntryCollection200ResponseItemsInnerTypeEnum = {
    LogEntry: 'log_entry'
} as const;

export type LogManagementGetLogEntryCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogEntryCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogEntryCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogEntryFrequencyCountResource.
 * @export
 * @interface LogManagementGetLogEntryFrequencyCountCollection200Response
 */
export interface LogManagementGetLogEntryFrequencyCountCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogEntryFrequencyCountCollection200Response
     */
    'type': LogManagementGetLogEntryFrequencyCountCollection200ResponseTypeEnum;
    /**
     * Array of LogEntryFrequencyCountResource.
     * @type {Array<LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogEntryFrequencyCountCollection200Response
     */
    'items': Array<LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner>;
}

export const LogManagementGetLogEntryFrequencyCountCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogEntryFrequencyCountCollection200ResponseTypeEnum = typeof LogManagementGetLogEntryFrequencyCountCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogEntryFrequencyCountCollection200ResponseTypeEnum];

/**
 * Resource representing the frequency count of log entries.
 * @export
 * @interface LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner
 */
export interface LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInnerTypeEnum;
    /**
     * Date associated with the frequency count.
     * @type {string}
     * @memberof LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner
     */
    'date': string;
    /**
     * Count of log entries for the specified date.
     * @type {number}
     * @memberof LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner
     */
    'count': number;
}

export const LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInnerTypeEnum = {
    LogEntryFrequencyCount: 'log_entry_frequency_count'
} as const;

export type LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogEntrySourceResource.
 * @export
 * @interface LogManagementGetLogEntrySourceCollection200Response
 */
export interface LogManagementGetLogEntrySourceCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogEntrySourceCollection200Response
     */
    'type': LogManagementGetLogEntrySourceCollection200ResponseTypeEnum;
    /**
     * Array of LogEntrySourceResource.
     * @type {Array<LogManagementGetLogEntrySourceCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogEntrySourceCollection200Response
     */
    'items': Array<LogManagementGetLogEntrySourceCollection200ResponseItemsInner>;
}

export const LogManagementGetLogEntrySourceCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogEntrySourceCollection200ResponseTypeEnum = typeof LogManagementGetLogEntrySourceCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogEntrySourceCollection200ResponseTypeEnum];

/**
 * Resource representing a log entry source.
 * @export
 * @interface LogManagementGetLogEntrySourceCollection200ResponseItemsInner
 */
export interface LogManagementGetLogEntrySourceCollection200ResponseItemsInner {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementGetLogEntrySourceCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogEntrySourceCollection200ResponseItemsInnerTypeEnum;
    /**
     * Source of the log entry.
     * @type {string}
     * @memberof LogManagementGetLogEntrySourceCollection200ResponseItemsInner
     */
    'source': string;
}

export const LogManagementGetLogEntrySourceCollection200ResponseItemsInnerTypeEnum = {
    LogEntrySource: 'log_entry_source'
} as const;

export type LogManagementGetLogEntrySourceCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogEntrySourceCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogEntrySourceCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogEntrySourceFrequencyResource.
 * @export
 * @interface LogManagementGetLogEntrySourceFrequencyCollection200Response
 */
export interface LogManagementGetLogEntrySourceFrequencyCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogEntrySourceFrequencyCollection200Response
     */
    'type': LogManagementGetLogEntrySourceFrequencyCollection200ResponseTypeEnum;
    /**
     * Array of LogEntrySourceFrequencyResource.
     * @type {Array<LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogEntrySourceFrequencyCollection200Response
     */
    'items': Array<LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner>;
}

export const LogManagementGetLogEntrySourceFrequencyCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogEntrySourceFrequencyCollection200ResponseTypeEnum = typeof LogManagementGetLogEntrySourceFrequencyCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogEntrySourceFrequencyCollection200ResponseTypeEnum];

/**
 * Resource representing the frequency count of log entries by source.
 * @export
 * @interface LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner
 */
export interface LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInnerTypeEnum;
    /**
     * Source associated with the frequency count.
     * @type {string}
     * @memberof LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner
     */
    'source': string;
    /**
     * Count of log entries for the specified source.
     * @type {number}
     * @memberof LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner
     */
    'count': number;
    /**
     * Percentage of log entries for the specified source.
     * @type {number}
     * @memberof LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner
     */
    'percentage': number;
}

export const LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInnerTypeEnum = {
    LogEntrySourceFrequency: 'log_entry_source_frequency'
} as const;

export type LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogEntryTagResource.
 * @export
 * @interface LogManagementGetLogEntryTagCollection200Response
 */
export interface LogManagementGetLogEntryTagCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogEntryTagCollection200Response
     */
    'type': LogManagementGetLogEntryTagCollection200ResponseTypeEnum;
    /**
     * Array of LogEntryTagResource.
     * @type {Array<LogManagementGetLogEntryTagCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogEntryTagCollection200Response
     */
    'items': Array<LogManagementGetLogEntryTagCollection200ResponseItemsInner>;
}

export const LogManagementGetLogEntryTagCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogEntryTagCollection200ResponseTypeEnum = typeof LogManagementGetLogEntryTagCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogEntryTagCollection200ResponseTypeEnum];

/**
 * Resource representing a log entry tag.
 * @export
 * @interface LogManagementGetLogEntryTagCollection200ResponseItemsInner
 */
export interface LogManagementGetLogEntryTagCollection200ResponseItemsInner {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementGetLogEntryTagCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogEntryTagCollection200ResponseItemsInnerTypeEnum;
    /**
     * Tag of the log entry.
     * @type {string}
     * @memberof LogManagementGetLogEntryTagCollection200ResponseItemsInner
     */
    'tag': string;
}

export const LogManagementGetLogEntryTagCollection200ResponseItemsInnerTypeEnum = {
    LogEntryTag: 'log_entry_tag'
} as const;

export type LogManagementGetLogEntryTagCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogEntryTagCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogEntryTagCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogEntryTagDistributionResource.
 * @export
 * @interface LogManagementGetLogEntryTagDistributionCollection200Response
 */
export interface LogManagementGetLogEntryTagDistributionCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogEntryTagDistributionCollection200Response
     */
    'type': LogManagementGetLogEntryTagDistributionCollection200ResponseTypeEnum;
    /**
     * Array of LogEntryTagDistributionResource.
     * @type {Array<LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogEntryTagDistributionCollection200Response
     */
    'items': Array<LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner>;
}

export const LogManagementGetLogEntryTagDistributionCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogEntryTagDistributionCollection200ResponseTypeEnum = typeof LogManagementGetLogEntryTagDistributionCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogEntryTagDistributionCollection200ResponseTypeEnum];

/**
 * Resource representing the distribution of log entries by tag.
 * @export
 * @interface LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner
 */
export interface LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInnerTypeEnum;
    /**
     * Tag associated with the distribution.
     * @type {string}
     * @memberof LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner
     */
    'tag': string;
    /**
     * Count of log entries for the specified tag.
     * @type {number}
     * @memberof LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner
     */
    'count': number;
}

export const LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInnerTypeEnum = {
    LogEntryTagDistribution: 'log_entry_tag_distribution'
} as const;

export type LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogFrequencyCountResource.
 * @export
 * @interface LogManagementGetLogFrequencyCountCollection200Response
 */
export interface LogManagementGetLogFrequencyCountCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogFrequencyCountCollection200Response
     */
    'type': LogManagementGetLogFrequencyCountCollection200ResponseTypeEnum;
    /**
     * Array of LogFrequencyCountResource.
     * @type {Array<LogManagementGetLogFrequencyCountCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogFrequencyCountCollection200Response
     */
    'items': Array<LogManagementGetLogFrequencyCountCollection200ResponseItemsInner>;
}

export const LogManagementGetLogFrequencyCountCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogFrequencyCountCollection200ResponseTypeEnum = typeof LogManagementGetLogFrequencyCountCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogFrequencyCountCollection200ResponseTypeEnum];

/**
 * Resource representing the frequency count of logs.
 * @export
 * @interface LogManagementGetLogFrequencyCountCollection200ResponseItemsInner
 */
export interface LogManagementGetLogFrequencyCountCollection200ResponseItemsInner {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementGetLogFrequencyCountCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogFrequencyCountCollection200ResponseItemsInnerTypeEnum;
    /**
     * Date associated with the frequency count.
     * @type {string}
     * @memberof LogManagementGetLogFrequencyCountCollection200ResponseItemsInner
     */
    'date': string;
    /**
     * Count of logs for the specified date.
     * @type {number}
     * @memberof LogManagementGetLogFrequencyCountCollection200ResponseItemsInner
     */
    'count': number;
}

export const LogManagementGetLogFrequencyCountCollection200ResponseItemsInnerTypeEnum = {
    LogFrequencyCount: 'log_frequency_count'
} as const;

export type LogManagementGetLogFrequencyCountCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogFrequencyCountCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogFrequencyCountCollection200ResponseItemsInnerTypeEnum];

/**
 * Collection of LogLevelStatisticsResource.
 * @export
 * @interface LogManagementGetLogLevelStatisticsCollection200Response
 */
export interface LogManagementGetLogLevelStatisticsCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogLevelStatisticsCollection200Response
     */
    'type': LogManagementGetLogLevelStatisticsCollection200ResponseTypeEnum;
    /**
     * Array of LogLevelStatisticsResource.
     * @type {Array<LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogLevelStatisticsCollection200Response
     */
    'items': Array<LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner>;
}

export const LogManagementGetLogLevelStatisticsCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogLevelStatisticsCollection200ResponseTypeEnum = typeof LogManagementGetLogLevelStatisticsCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogLevelStatisticsCollection200ResponseTypeEnum];

/**
 * Resource representing the statistics of logs by level.
 * @export
 * @interface LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner
 */
export interface LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerTypeEnum;
    /**
     * 
     * @type {LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel}
     * @memberof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner
     */
    'level': LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel;
    /**
     * Count of logs for the specified level.
     * @type {number}
     * @memberof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner
     */
    'count': number;
    /**
     * Percentage of logs for the specified level.
     * @type {number}
     * @memberof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner
     */
    'percentage': number;
}

export const LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerTypeEnum = {
    LogLevelStatistics: 'log_level_statistics'
} as const;

export type LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerTypeEnum];

/**
 * Level associated with the statistics.
 * @export
 * @interface LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel
 */
export interface LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel {
    /**
     * Name of the level.
     * @type {string}
     * @memberof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel
     */
    'name': LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelNameEnum;
    /**
     * Value of the level.
     * @type {number}
     * @memberof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel
     */
    'value': LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelValueEnum;
}

export const LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelNameEnum = {
    Debug: 'Debug',
    Info: 'Info',
    Notice: 'Notice',
    Warning: 'Warning',
    Error: 'Error',
    Critical: 'Critical',
    Alert: 'Alert',
    Emergency: 'Emergency'
} as const;

export type LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelNameEnum = typeof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelNameEnum[keyof typeof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelNameEnum];
export const LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelValueEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelValueEnum = typeof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelValueEnum[keyof typeof LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevelValueEnum];

/**
 * Collection of LogNamespaceResource.
 * @export
 * @interface LogManagementGetLogNamespaceCollection200Response
 */
export interface LogManagementGetLogNamespaceCollection200Response {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementGetLogNamespaceCollection200Response
     */
    'type': LogManagementGetLogNamespaceCollection200ResponseTypeEnum;
    /**
     * Array of LogNamespaceResource.
     * @type {Array<LogManagementGetLogNamespaceCollection200ResponseItemsInner>}
     * @memberof LogManagementGetLogNamespaceCollection200Response
     */
    'items': Array<LogManagementGetLogNamespaceCollection200ResponseItemsInner>;
}

export const LogManagementGetLogNamespaceCollection200ResponseTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementGetLogNamespaceCollection200ResponseTypeEnum = typeof LogManagementGetLogNamespaceCollection200ResponseTypeEnum[keyof typeof LogManagementGetLogNamespaceCollection200ResponseTypeEnum];

/**
 * Resource representing a log namespace.
 * @export
 * @interface LogManagementGetLogNamespaceCollection200ResponseItemsInner
 */
export interface LogManagementGetLogNamespaceCollection200ResponseItemsInner {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementGetLogNamespaceCollection200ResponseItemsInner
     */
    'type': LogManagementGetLogNamespaceCollection200ResponseItemsInnerTypeEnum;
    /**
     * Namespace of the log.
     * @type {string}
     * @memberof LogManagementGetLogNamespaceCollection200ResponseItemsInner
     */
    'namespace': string;
}

export const LogManagementGetLogNamespaceCollection200ResponseItemsInnerTypeEnum = {
    LogNamespace: 'log_namespace'
} as const;

export type LogManagementGetLogNamespaceCollection200ResponseItemsInnerTypeEnum = typeof LogManagementGetLogNamespaceCollection200ResponseItemsInnerTypeEnum[keyof typeof LogManagementGetLogNamespaceCollection200ResponseItemsInnerTypeEnum];

/**
 * 
 * @export
 * @interface LogManagementLogCollectLog
 */
export interface LogManagementLogCollectLog {
    /**
     * 
     * @type {LogManagementCollectRequestCollectLogsInnerLog}
     * @memberof LogManagementLogCollectLog
     */
    'log': LogManagementCollectRequestCollectLogsInnerLog;
    /**
     * 
     * @type {Array<LogManagementCollectRequestCollectLogsInnerEntriesInner>}
     * @memberof LogManagementLogCollectLog
     */
    'entries': Array<LogManagementCollectRequestCollectLogsInnerEntriesInner>;
}
/**
 * 
 * @export
 * @interface LogManagementLogCollectLogEntry
 */
export interface LogManagementLogCollectLogEntry {
    /**
     * The source of the entry, indicating what part of the system the entry is from.
     * @type {string}
     * @memberof LogManagementLogCollectLogEntry
     */
    'source': string;
    /**
     * The context of the entry, providing additional information to help understand the entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCollectLogEntry
     */
    'context': { [key: string]: any; };
    /**
     * The attributes of the entry, providing additional information not included in the main message.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCollectLogEntry
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LogManagementLogCollectLogEntry
     */
    'tags': Array<string>;
    /**
     * The timestamp indicating when the entry occurred.
     * @type {string}
     * @memberof LogManagementLogCollectLogEntry
     */
    'occurred_at': string;
}
/**
 * 
 * @export
 * @interface LogManagementLogCreateLog
 */
export interface LogManagementLogCreateLog {
    /**
     * The namespace associated with the log.
     * @type {string}
     * @memberof LogManagementLogCreateLog
     */
    'namespace': string;
    /**
     * The severity level of the log.
     * @type {number}
     * @memberof LogManagementLogCreateLog
     */
    'level': LogManagementLogCreateLogLevelEnum;
    /**
     * The template used for formatting the log message.
     * @type {string}
     * @memberof LogManagementLogCreateLog
     */
    'template': string;
}

export const LogManagementLogCreateLogLevelEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementLogCreateLogLevelEnum = typeof LogManagementLogCreateLogLevelEnum[keyof typeof LogManagementLogCreateLogLevelEnum];

/**
 * 
 * @export
 * @interface LogManagementLogCreateLogEntry
 */
export interface LogManagementLogCreateLogEntry {
    /**
     * The identity of the associated log.
     * @type {string}
     * @memberof LogManagementLogCreateLogEntry
     */
    'log_identity': string;
    /**
     * The source of the entry, indicating what part of the system the entry is from.
     * @type {string}
     * @memberof LogManagementLogCreateLogEntry
     */
    'source': string;
    /**
     * The context of the entry, providing additional information to help understand the entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCreateLogEntry
     */
    'context': { [key: string]: any; };
    /**
     * The attributes of the entry, providing additional information not included in the main message.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCreateLogEntry
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LogManagementLogCreateLogEntry
     */
    'tags': Array<string>;
    /**
     * The timestamp indicating when the entry occurred.
     * @type {string}
     * @memberof LogManagementLogCreateLogEntry
     */
    'occurred_at': string;
}
/**
 * The order of the log entries.
 * @export
 * @enum {string}
 */

export const LogManagementLogLogEntryFilterOrder = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type LogManagementLogLogEntryFilterOrder = typeof LogManagementLogLogEntryFilterOrder[keyof typeof LogManagementLogLogEntryFilterOrder];


/**
 * Resource representing a log entry.
 * @export
 * @interface LogManagementLogLogEntryResource
 */
export interface LogManagementLogLogEntryResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'type': LogManagementLogLogEntryResourceTypeEnum;
    /**
     * Unique identity of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'identity': string;
    /**
     * Identity of the associated log.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'log_identity': string;
    /**
     * Source of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'source': string;
    /**
     * Contextual information for the log entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogLogEntryResource
     */
    'context': { [key: string]: any; };
    /**
     * Attributes associated with the log entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogLogEntryResource
     */
    'attributes': { [key: string]: any; };
    /**
     * Tags associated with the log entry.
     * @type {Array<string>}
     * @memberof LogManagementLogLogEntryResource
     */
    'tags': Array<string>;
    /**
     * Timestamp when the log entry occurred.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'occurred_at': string;
    /**
     * Timestamp when the log entry was created.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'created_at': string;
    /**
     * Timestamp when the log entry was last updated.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'updated_at': string;
}

export const LogManagementLogLogEntryResourceTypeEnum = {
    LogEntry: 'log_entry'
} as const;

export type LogManagementLogLogEntryResourceTypeEnum = typeof LogManagementLogLogEntryResourceTypeEnum[keyof typeof LogManagementLogLogEntryResourceTypeEnum];

/**
 * Paginated collection of LogEntryResource.
 * @export
 * @interface LogManagementLogLogEntryResourcePaginatedCollectionResource
 */
export interface LogManagementLogLogEntryResourcePaginatedCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'type': LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum;
    /**
     * Current page number.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'page': number;
    /**
     * Number of items per page.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'items_per_page': number;
    /**
     * Total number of items.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'total_items': number;
    /**
     * First item index.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'first': number;
    /**
     * Last item index.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'last': number;
    /**
     * Next page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'next'?: number | null;
    /**
     * Previous page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'previous'?: number | null;
    /**
     * Array of LogEntryResource.
     * @type {Array<LogManagementGetLogEntryCollection200ResponseItemsInner>}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'items': Array<LogManagementGetLogEntryCollection200ResponseItemsInner>;
}

export const LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum = {
    PaginatedCollection: 'paginated_collection'
} as const;

export type LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum = typeof LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum[keyof typeof LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum];

/**
 * Resource representing a log entry source.
 * @export
 * @interface LogManagementLogLogEntrySourceResource
 */
export interface LogManagementLogLogEntrySourceResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogEntrySourceResource
     */
    'type': LogManagementLogLogEntrySourceResourceTypeEnum;
    /**
     * Source of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntrySourceResource
     */
    'source': string;
}

export const LogManagementLogLogEntrySourceResourceTypeEnum = {
    LogEntrySource: 'log_entry_source'
} as const;

export type LogManagementLogLogEntrySourceResourceTypeEnum = typeof LogManagementLogLogEntrySourceResourceTypeEnum[keyof typeof LogManagementLogLogEntrySourceResourceTypeEnum];

/**
 * Collection of LogEntrySourceResource.
 * @export
 * @interface LogManagementLogLogEntrySourceResourceCollectionResource
 */
export interface LogManagementLogLogEntrySourceResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogEntrySourceResourceCollectionResource
     */
    'type': LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntrySourceResource.
     * @type {Array<LogManagementGetLogEntrySourceCollection200ResponseItemsInner>}
     * @memberof LogManagementLogLogEntrySourceResourceCollectionResource
     */
    'items': Array<LogManagementGetLogEntrySourceCollection200ResponseItemsInner>;
}

export const LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum = typeof LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum];

/**
 * Resource representing a log entry tag.
 * @export
 * @interface LogManagementLogLogEntryTagResource
 */
export interface LogManagementLogLogEntryTagResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogEntryTagResource
     */
    'type': LogManagementLogLogEntryTagResourceTypeEnum;
    /**
     * Tag of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntryTagResource
     */
    'tag': string;
}

export const LogManagementLogLogEntryTagResourceTypeEnum = {
    LogEntryTag: 'log_entry_tag'
} as const;

export type LogManagementLogLogEntryTagResourceTypeEnum = typeof LogManagementLogLogEntryTagResourceTypeEnum[keyof typeof LogManagementLogLogEntryTagResourceTypeEnum];

/**
 * Collection of LogEntryTagResource.
 * @export
 * @interface LogManagementLogLogEntryTagResourceCollectionResource
 */
export interface LogManagementLogLogEntryTagResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogEntryTagResourceCollectionResource
     */
    'type': LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntryTagResource.
     * @type {Array<LogManagementGetLogEntryTagCollection200ResponseItemsInner>}
     * @memberof LogManagementLogLogEntryTagResourceCollectionResource
     */
    'items': Array<LogManagementGetLogEntryTagCollection200ResponseItemsInner>;
}

export const LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum = typeof LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum];

/**
 * The order of the logs.
 * @export
 * @enum {string}
 */

export const LogManagementLogLogFilterOrder = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type LogManagementLogLogFilterOrder = typeof LogManagementLogLogFilterOrder[keyof typeof LogManagementLogLogFilterOrder];


/**
 * The field to sort the logs by.
 * @export
 * @enum {string}
 */

export const LogManagementLogLogFilterSortBy = {
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    FirstEntryOccurredAt: 'firstEntryOccurredAt',
    LastEntryOccurredAt: 'lastEntryOccurredAt',
    Level: 'level'
} as const;

export type LogManagementLogLogFilterSortBy = typeof LogManagementLogLogFilterSortBy[keyof typeof LogManagementLogLogFilterSortBy];


/**
 * Resource representing a log namespace.
 * @export
 * @interface LogManagementLogLogNamespaceResource
 */
export interface LogManagementLogLogNamespaceResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogNamespaceResource
     */
    'type': LogManagementLogLogNamespaceResourceTypeEnum;
    /**
     * Namespace of the log.
     * @type {string}
     * @memberof LogManagementLogLogNamespaceResource
     */
    'namespace': string;
}

export const LogManagementLogLogNamespaceResourceTypeEnum = {
    LogNamespace: 'log_namespace'
} as const;

export type LogManagementLogLogNamespaceResourceTypeEnum = typeof LogManagementLogLogNamespaceResourceTypeEnum[keyof typeof LogManagementLogLogNamespaceResourceTypeEnum];

/**
 * Collection of LogNamespaceResource.
 * @export
 * @interface LogManagementLogLogNamespaceResourceCollectionResource
 */
export interface LogManagementLogLogNamespaceResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogNamespaceResourceCollectionResource
     */
    'type': LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum;
    /**
     * Array of LogNamespaceResource.
     * @type {Array<LogManagementGetLogNamespaceCollection200ResponseItemsInner>}
     * @memberof LogManagementLogLogNamespaceResourceCollectionResource
     */
    'items': Array<LogManagementGetLogNamespaceCollection200ResponseItemsInner>;
}

export const LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum = typeof LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum];

/**
 * Resource representing a log.
 * @export
 * @interface LogManagementLogLogResource
 */
export interface LogManagementLogLogResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'type': LogManagementLogLogResourceTypeEnum;
    /**
     * Unique identity of the log.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'identity': string;
    /**
     * The namespace of the log.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'namespace': string;
    /**
     * 
     * @type {LogManagementGetLogCollection200ResponseItemsInnerLevel}
     * @memberof LogManagementLogLogResource
     */
    'level': LogManagementGetLogCollection200ResponseItemsInnerLevel;
    /**
     * The template for formatting the message.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'template': string;
    /**
     * Timestamp of the first entry occurrence, if available.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'first_entry_occurred_at'?: string | null;
    /**
     * Timestamp of the last entry occurrence, if available.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'last_entry_occurred_at'?: string | null;
    /**
     * Timestamp when the log was created.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'created_at': string;
    /**
     * Timestamp when the log was last updated.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'updated_at': string;
}

export const LogManagementLogLogResourceTypeEnum = {
    Log: 'log'
} as const;

export type LogManagementLogLogResourceTypeEnum = typeof LogManagementLogLogResourceTypeEnum[keyof typeof LogManagementLogLogResourceTypeEnum];

/**
 * Paginated collection of LogResource.
 * @export
 * @interface LogManagementLogLogResourcePaginatedCollectionResource
 */
export interface LogManagementLogLogResourcePaginatedCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'type': LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum;
    /**
     * Current page number.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'page': number;
    /**
     * Number of items per page.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'items_per_page': number;
    /**
     * Total number of items.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'total_items': number;
    /**
     * First item index.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'first': number;
    /**
     * Last item index.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'last': number;
    /**
     * Next page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'next'?: number | null;
    /**
     * Previous page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'previous'?: number | null;
    /**
     * Array of LogResource.
     * @type {Array<LogManagementGetLogCollection200ResponseItemsInner>}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'items': Array<LogManagementGetLogCollection200ResponseItemsInner>;
}

export const LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum = {
    PaginatedCollection: 'paginated_collection'
} as const;

export type LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum = typeof LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum[keyof typeof LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum];

/**
 * The frequency for log statistics, specifying how the data should be aggregated.
 * @export
 * @enum {string}
 */

export const LogManagementLogStatisticsFrequency = {
    Yearly: 'yearly',
    Quarterly: 'quarterly',
    Monthly: 'monthly',
    Weekly: 'weekly',
    Daily: 'daily',
    Hourly: 'hourly'
} as const;

export type LogManagementLogStatisticsFrequency = typeof LogManagementLogStatisticsFrequency[keyof typeof LogManagementLogStatisticsFrequency];


/**
 * Resource representing the frequency count of log entries.
 * @export
 * @interface LogManagementLogStatisticsLogEntryFrequencyCountResource
 */
export interface LogManagementLogStatisticsLogEntryFrequencyCountResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResource
     */
    'type': LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum;
    /**
     * Date associated with the frequency count.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResource
     */
    'date': string;
    /**
     * Count of log entries for the specified date.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResource
     */
    'count': number;
}

export const LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum = {
    LogEntryFrequencyCount: 'log_entry_frequency_count'
} as const;

export type LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum];

/**
 * Collection of LogEntryFrequencyCountResource.
 * @export
 * @interface LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntryFrequencyCountResource.
     * @type {Array<LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner>}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource
     */
    'items': Array<LogManagementGetLogEntryFrequencyCountCollection200ResponseItemsInner>;
}

export const LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum];

/**
 * Resource representing the frequency count of log entries by source.
 * @export
 * @interface LogManagementLogStatisticsLogEntrySourceFrequencyResource
 */
export interface LogManagementLogStatisticsLogEntrySourceFrequencyResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'type': LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum;
    /**
     * Source associated with the frequency count.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'source': string;
    /**
     * Count of log entries for the specified source.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'count': number;
    /**
     * Percentage of log entries for the specified source.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'percentage': number;
}

export const LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum = {
    LogEntrySourceFrequency: 'log_entry_source_frequency'
} as const;

export type LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum = typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum];

/**
 * Collection of LogEntrySourceFrequencyResource.
 * @export
 * @interface LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntrySourceFrequencyResource.
     * @type {Array<LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner>}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource
     */
    'items': Array<LogManagementGetLogEntrySourceFrequencyCollection200ResponseItemsInner>;
}

export const LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum];

/**
 * Resource representing the distribution of log entries by tag.
 * @export
 * @interface LogManagementLogStatisticsLogEntryTagDistributionResource
 */
export interface LogManagementLogStatisticsLogEntryTagDistributionResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResource
     */
    'type': LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum;
    /**
     * Tag associated with the distribution.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResource
     */
    'tag': string;
    /**
     * Count of log entries for the specified tag.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResource
     */
    'count': number;
}

export const LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum = {
    LogEntryTagDistribution: 'log_entry_tag_distribution'
} as const;

export type LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum];

/**
 * Collection of LogEntryTagDistributionResource.
 * @export
 * @interface LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntryTagDistributionResource.
     * @type {Array<LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner>}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource
     */
    'items': Array<LogManagementGetLogEntryTagDistributionCollection200ResponseItemsInner>;
}

export const LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum];

/**
 * Resource representing the frequency count of logs.
 * @export
 * @interface LogManagementLogStatisticsLogFrequencyCountResource
 */
export interface LogManagementLogStatisticsLogFrequencyCountResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResource
     */
    'type': LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum;
    /**
     * Date associated with the frequency count.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResource
     */
    'date': string;
    /**
     * Count of logs for the specified date.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResource
     */
    'count': number;
}

export const LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum = {
    LogFrequencyCount: 'log_frequency_count'
} as const;

export type LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum = typeof LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum];

/**
 * Collection of LogFrequencyCountResource.
 * @export
 * @interface LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum;
    /**
     * Array of LogFrequencyCountResource.
     * @type {Array<LogManagementGetLogFrequencyCountCollection200ResponseItemsInner>}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource
     */
    'items': Array<LogManagementGetLogFrequencyCountCollection200ResponseItemsInner>;
}

export const LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum];

/**
 * Resource representing the statistics of logs by level.
 * @export
 * @interface LogManagementLogStatisticsLogLevelStatisticsResource
 */
export interface LogManagementLogStatisticsLogLevelStatisticsResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'type': LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum;
    /**
     * 
     * @type {LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'level': LogManagementGetLogLevelStatisticsCollection200ResponseItemsInnerLevel;
    /**
     * Count of logs for the specified level.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'count': number;
    /**
     * Percentage of logs for the specified level.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'percentage': number;
}

export const LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum = {
    LogLevelStatistics: 'log_level_statistics'
} as const;

export type LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum = typeof LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum];

/**
 * Collection of LogLevelStatisticsResource.
 * @export
 * @interface LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum;
    /**
     * Array of LogLevelStatisticsResource.
     * @type {Array<LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner>}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource
     */
    'items': Array<LogManagementGetLogLevelStatisticsCollection200ResponseItemsInner>;
}

export const LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum];

/**
 * Resource representing the ping
 * @export
 * @interface Ping200Response
 */
export interface Ping200Response {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof Ping200Response
     */
    'type': Ping200ResponseTypeEnum;
    /**
     * A random quote from Hannibal, The Carthaginian General.
     * @type {string}
     * @memberof Ping200Response
     */
    'quote'?: string;
    /**
     * The date and time
     * @type {string}
     * @memberof Ping200Response
     */
    'time': string;
}

export const Ping200ResponseTypeEnum = {
    Ping: 'ping'
} as const;

export type Ping200ResponseTypeEnum = typeof Ping200ResponseTypeEnum[keyof typeof Ping200ResponseTypeEnum];

/**
 * Resource representing the ping
 * @export
 * @interface SharedPingResource
 */
export interface SharedPingResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof SharedPingResource
     */
    'type': SharedPingResourceTypeEnum;
    /**
     * A random quote from Hannibal, The Carthaginian General.
     * @type {string}
     * @memberof SharedPingResource
     */
    'quote'?: string;
    /**
     * The date and time
     * @type {string}
     * @memberof SharedPingResource
     */
    'time': string;
}

export const SharedPingResourceTypeEnum = {
    Ping: 'ping'
} as const;

export type SharedPingResourceTypeEnum = typeof SharedPingResourceTypeEnum[keyof typeof SharedPingResourceTypeEnum];


/**
 * LogManagementApi - axios parameter creator
 * @export
 */
export const LogManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Collect multiple log entries, for multiple logs.
         * @summary Collect Multiple Logs
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollect: async (requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect log entries from a log.
         * @summary Collect Log Entries
         * @param {LogManagementCollectRequestCollectLogsInner} [logManagementCollectRequestCollectLogsInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollectLog: async (logManagementCollectRequestCollectLogsInner?: LogManagementCollectRequestCollectLogsInner, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logManagementCollectRequestCollectLogsInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new log.
         * @summary Create Log
         * @param {LogManagementCollectRequestCollectLogsInnerLog} [logManagementCollectRequestCollectLogsInnerLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLog: async (logManagementCollectRequestCollectLogsInnerLog?: LogManagementCollectRequestCollectLogsInnerLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logManagementCollectRequestCollectLogsInnerLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new log entry.
         * @summary Create Log Entry
         * @param {LogManagementCreateLogEntryRequest} [logManagementCreateLogEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLogEntry: async (logManagementCreateLogEntryRequest?: LogManagementCreateLogEntryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logManagementCreateLogEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a log by identity.
         * @summary Delete Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLog: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementDeleteLog', 'identity', identity)
            const localVarPath = `/log-management/log/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a log entry by identity.
         * @summary Delete Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLogEntry: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementDeleteLogEntry', 'identity', identity)
            const localVarPath = `/log-management/log/entry/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a log by its identity.
         * @summary Get Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLog: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementGetLog', 'identity', identity)
            const localVarPath = `/log-management/log/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of logs.
         * @summary Get Log Collection
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>} [levels] 
         * @param {string} [contains] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {'createdAt' | 'updatedAt' | 'firstEntryOccurredAt' | 'lastEntryOccurredAt' | 'level'} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogCollection: async (page?: number, itemsPerPage?: number, levels?: Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>, contains?: string, from?: string, to?: string, order?: 'ASC' | 'DESC', sortBy?: 'createdAt' | 'updatedAt' | 'firstEntryOccurredAt' | 'lastEntryOccurredAt' | 'level', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['items_per_page'] = itemsPerPage;
            }

            if (levels) {
                localVarQueryParameter['levels[]'] = levels;
            }

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a log entry by its identity.
         * @summary Get Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntry: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementGetLogEntry', 'identity', identity)
            const localVarPath = `/log-management/log/entry/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log entries.
         * @summary Get Log Entry Collection
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {string} [logIdentity] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [source] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryCollection: async (page?: number, itemsPerPage?: number, logIdentity?: string, before?: string, after?: string, order?: 'ASC' | 'DESC', source?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['items_per_page'] = itemsPerPage;
            }

            if (logIdentity !== undefined) {
                localVarQueryParameter['log_identity'] = logIdentity;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the frequency count of log entries.
         * @summary Get Log Entry Frequency Count
         * @param {'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryFrequencyCountCollection: async (frequency: 'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'frequency' is not null or undefined
            assertParamExists('logManagementGetLogEntryFrequencyCountCollection', 'frequency', frequency)
            const localVarPath = `/log-management/log/statistic/entry-frequency-count/{frequency}`
                .replace(`{${"frequency"}}`, encodeURIComponent(String(frequency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log entry sources.
         * @summary Get Log Entry Source Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the frequency count of log entry sources.
         * @summary Get Log Entry Source Frequency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceFrequencyCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/statistic/entry-source-frequency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log entry tags.
         * @summary Get Log Entry Tag Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the distribution of log entry tags.
         * @summary Get Log Entry Tag Distribution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagDistributionCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/statistic/entry-tag-distribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the frequency count of logs.
         * @summary Get Log Frequency Count
         * @param {'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogFrequencyCountCollection: async (frequency: 'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'frequency' is not null or undefined
            assertParamExists('logManagementGetLogFrequencyCountCollection', 'frequency', frequency)
            const localVarPath = `/log-management/log/statistic/frequency-count/{frequency}`
                .replace(`{${"frequency"}}`, encodeURIComponent(String(frequency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the statistics of log levels.
         * @summary Get Log Level Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogLevelStatisticsCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/statistic/level-statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log namespaces.
         * @summary Get Log Namespace Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogNamespaceCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/namespace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogManagementApi - functional programming interface
 * @export
 */
export const LogManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Collect multiple log entries, for multiple logs.
         * @summary Collect Multiple Logs
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCollect(requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCollect(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect log entries from a log.
         * @summary Collect Log Entries
         * @param {LogManagementCollectRequestCollectLogsInner} [logManagementCollectRequestCollectLogsInner] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCollectLog(logManagementCollectRequestCollectLogsInner?: LogManagementCollectRequestCollectLogsInner, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCollectLog(logManagementCollectRequestCollectLogsInner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new log.
         * @summary Create Log
         * @param {LogManagementCollectRequestCollectLogsInnerLog} [logManagementCollectRequestCollectLogsInnerLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCreateLog(logManagementCollectRequestCollectLogsInnerLog?: LogManagementCollectRequestCollectLogsInnerLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogCollection200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCreateLog(logManagementCollectRequestCollectLogsInnerLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new log entry.
         * @summary Create Log Entry
         * @param {LogManagementCreateLogEntryRequest} [logManagementCreateLogEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCreateLogEntry(logManagementCreateLogEntryRequest?: LogManagementCreateLogEntryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntryCollection200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCreateLogEntry(logManagementCreateLogEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a log by identity.
         * @summary Delete Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementDeleteLog(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementDeleteLog(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a log entry by identity.
         * @summary Delete Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementDeleteLogEntry(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementDeleteLogEntry(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a log by its identity.
         * @summary Get Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLog(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogCollection200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLog(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of logs.
         * @summary Get Log Collection
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>} [levels] 
         * @param {string} [contains] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {'createdAt' | 'updatedAt' | 'firstEntryOccurredAt' | 'lastEntryOccurredAt' | 'level'} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogCollection(page?: number, itemsPerPage?: number, levels?: Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>, contains?: string, from?: string, to?: string, order?: 'ASC' | 'DESC', sortBy?: 'createdAt' | 'updatedAt' | 'firstEntryOccurredAt' | 'lastEntryOccurredAt' | 'level', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogCollection(page, itemsPerPage, levels, contains, from, to, order, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a log entry by its identity.
         * @summary Get Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntry(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntryCollection200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntry(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log entries.
         * @summary Get Log Entry Collection
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {string} [logIdentity] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {'ASC' | 'DESC'} [order] 
         * @param {string} [source] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryCollection(page?: number, itemsPerPage?: number, logIdentity?: string, before?: string, after?: string, order?: 'ASC' | 'DESC', source?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntryCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryCollection(page, itemsPerPage, logIdentity, before, after, order, source, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the frequency count of log entries.
         * @summary Get Log Entry Frequency Count
         * @param {'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryFrequencyCountCollection(frequency: 'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntryFrequencyCountCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryFrequencyCountCollection(frequency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log entry sources.
         * @summary Get Log Entry Source Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntrySourceCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntrySourceCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntrySourceCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the frequency count of log entry sources.
         * @summary Get Log Entry Source Frequency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntrySourceFrequencyCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntrySourceFrequencyCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntrySourceFrequencyCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log entry tags.
         * @summary Get Log Entry Tag Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryTagCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntryTagCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryTagCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the distribution of log entry tags.
         * @summary Get Log Entry Tag Distribution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryTagDistributionCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogEntryTagDistributionCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryTagDistributionCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the frequency count of logs.
         * @summary Get Log Frequency Count
         * @param {'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogFrequencyCountCollection(frequency: 'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogFrequencyCountCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogFrequencyCountCollection(frequency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the statistics of log levels.
         * @summary Get Log Level Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogLevelStatisticsCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogLevelStatisticsCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogLevelStatisticsCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log namespaces.
         * @summary Get Log Namespace Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogNamespaceCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementGetLogNamespaceCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogNamespaceCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogManagementApi - factory interface
 * @export
 */
export const LogManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogManagementApiFp(configuration)
    return {
        /**
         * Collect multiple log entries, for multiple logs.
         * @summary Collect Multiple Logs
         * @param {LogManagementApiLogManagementCollectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollect(requestParameters: LogManagementApiLogManagementCollectRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementCollect(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect log entries from a log.
         * @summary Collect Log Entries
         * @param {LogManagementApiLogManagementCollectLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollectLog(requestParameters: LogManagementApiLogManagementCollectLogRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementCollectLog(requestParameters.logManagementCollectRequestCollectLogsInner, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new log.
         * @summary Create Log
         * @param {LogManagementApiLogManagementCreateLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLog(requestParameters: LogManagementApiLogManagementCreateLogRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogCollection200ResponseItemsInner> {
            return localVarFp.logManagementCreateLog(requestParameters.logManagementCollectRequestCollectLogsInnerLog, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new log entry.
         * @summary Create Log Entry
         * @param {LogManagementApiLogManagementCreateLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLogEntry(requestParameters: LogManagementApiLogManagementCreateLogEntryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntryCollection200ResponseItemsInner> {
            return localVarFp.logManagementCreateLogEntry(requestParameters.logManagementCreateLogEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a log by identity.
         * @summary Delete Log
         * @param {LogManagementApiLogManagementDeleteLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLog(requestParameters: LogManagementApiLogManagementDeleteLogRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementDeleteLog(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a log entry by identity.
         * @summary Delete Log Entry
         * @param {LogManagementApiLogManagementDeleteLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLogEntry(requestParameters: LogManagementApiLogManagementDeleteLogEntryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementDeleteLogEntry(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a log by its identity.
         * @summary Get Log
         * @param {LogManagementApiLogManagementGetLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLog(requestParameters: LogManagementApiLogManagementGetLogRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogCollection200ResponseItemsInner> {
            return localVarFp.logManagementGetLog(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of logs.
         * @summary Get Log Collection
         * @param {LogManagementApiLogManagementGetLogCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogCollection(requestParameters: LogManagementApiLogManagementGetLogCollectionRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogCollection200Response> {
            return localVarFp.logManagementGetLogCollection(requestParameters.page, requestParameters.itemsPerPage, requestParameters.levels, requestParameters.contains, requestParameters.from, requestParameters.to, requestParameters.order, requestParameters.sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a log entry by its identity.
         * @summary Get Log Entry
         * @param {LogManagementApiLogManagementGetLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntry(requestParameters: LogManagementApiLogManagementGetLogEntryRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntryCollection200ResponseItemsInner> {
            return localVarFp.logManagementGetLogEntry(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log entries.
         * @summary Get Log Entry Collection
         * @param {LogManagementApiLogManagementGetLogEntryCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryCollection(requestParameters: LogManagementApiLogManagementGetLogEntryCollectionRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntryCollection200Response> {
            return localVarFp.logManagementGetLogEntryCollection(requestParameters.page, requestParameters.itemsPerPage, requestParameters.logIdentity, requestParameters.before, requestParameters.after, requestParameters.order, requestParameters.source, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the frequency count of log entries.
         * @summary Get Log Entry Frequency Count
         * @param {LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntryFrequencyCountCollection200Response> {
            return localVarFp.logManagementGetLogEntryFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log entry sources.
         * @summary Get Log Entry Source Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntrySourceCollection200Response> {
            return localVarFp.logManagementGetLogEntrySourceCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the frequency count of log entry sources.
         * @summary Get Log Entry Source Frequency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceFrequencyCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntrySourceFrequencyCollection200Response> {
            return localVarFp.logManagementGetLogEntrySourceFrequencyCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log entry tags.
         * @summary Get Log Entry Tag Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntryTagCollection200Response> {
            return localVarFp.logManagementGetLogEntryTagCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the distribution of log entry tags.
         * @summary Get Log Entry Tag Distribution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagDistributionCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogEntryTagDistributionCollection200Response> {
            return localVarFp.logManagementGetLogEntryTagDistributionCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the frequency count of logs.
         * @summary Get Log Frequency Count
         * @param {LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogFrequencyCountCollection200Response> {
            return localVarFp.logManagementGetLogFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the statistics of log levels.
         * @summary Get Log Level Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogLevelStatisticsCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogLevelStatisticsCollection200Response> {
            return localVarFp.logManagementGetLogLevelStatisticsCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log namespaces.
         * @summary Get Log Namespace Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogNamespaceCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementGetLogNamespaceCollection200Response> {
            return localVarFp.logManagementGetLogNamespaceCollection(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for logManagementCollect operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCollectRequest
 */
export interface LogManagementApiLogManagementCollectRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementApiLogManagementCollect
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for logManagementCollectLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCollectLogRequest
 */
export interface LogManagementApiLogManagementCollectLogRequest {
    /**
     * 
     * @type {LogManagementCollectRequestCollectLogsInner}
     * @memberof LogManagementApiLogManagementCollectLog
     */
    readonly logManagementCollectRequestCollectLogsInner?: LogManagementCollectRequestCollectLogsInner
}

/**
 * Request parameters for logManagementCreateLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCreateLogRequest
 */
export interface LogManagementApiLogManagementCreateLogRequest {
    /**
     * 
     * @type {LogManagementCollectRequestCollectLogsInnerLog}
     * @memberof LogManagementApiLogManagementCreateLog
     */
    readonly logManagementCollectRequestCollectLogsInnerLog?: LogManagementCollectRequestCollectLogsInnerLog
}

/**
 * Request parameters for logManagementCreateLogEntry operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCreateLogEntryRequest
 */
export interface LogManagementApiLogManagementCreateLogEntryRequest {
    /**
     * 
     * @type {LogManagementCreateLogEntryRequest}
     * @memberof LogManagementApiLogManagementCreateLogEntry
     */
    readonly logManagementCreateLogEntryRequest?: LogManagementCreateLogEntryRequest
}

/**
 * Request parameters for logManagementDeleteLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementDeleteLogRequest
 */
export interface LogManagementApiLogManagementDeleteLogRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementDeleteLog
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementDeleteLogEntry operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementDeleteLogEntryRequest
 */
export interface LogManagementApiLogManagementDeleteLogEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementDeleteLogEntry
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementGetLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogRequest
 */
export interface LogManagementApiLogManagementGetLogRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLog
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementGetLogCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogCollectionRequest {
    /**
     * The page number for pagination. Defaults to 1.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly page?: number

    /**
     * The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly itemsPerPage?: number

    /**
     * 
     * @type {Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly levels?: Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly contains?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly from?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly to?: string

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * 
     * @type {'createdAt' | 'updatedAt' | 'firstEntryOccurredAt' | 'lastEntryOccurredAt' | 'level'}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly sortBy?: 'createdAt' | 'updatedAt' | 'firstEntryOccurredAt' | 'lastEntryOccurredAt' | 'level'
}

/**
 * Request parameters for logManagementGetLogEntry operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogEntryRequest
 */
export interface LogManagementApiLogManagementGetLogEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntry
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementGetLogEntryCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogEntryCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogEntryCollectionRequest {
    /**
     * The page number for pagination. Defaults to 1.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly page?: number

    /**
     * The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly itemsPerPage?: number

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly logIdentity?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly after?: string

    /**
     * 
     * @type {'ASC' | 'DESC'}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly order?: 'ASC' | 'DESC'

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly source?: string
}

/**
 * Request parameters for logManagementGetLogEntryFrequencyCountCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest {
    /**
     * 
     * @type {'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'}
     * @memberof LogManagementApiLogManagementGetLogEntryFrequencyCountCollection
     */
    readonly frequency: 'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'
}

/**
 * Request parameters for logManagementGetLogFrequencyCountCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest {
    /**
     * 
     * @type {'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'}
     * @memberof LogManagementApiLogManagementGetLogFrequencyCountCollection
     */
    readonly frequency: 'yearly' | 'quarterly' | 'monthly' | 'weekly' | 'daily' | 'hourly'
}

/**
 * LogManagementApi - object-oriented interface
 * @export
 * @class LogManagementApi
 * @extends {BaseAPI}
 */
export class LogManagementApi extends BaseAPI {
    /**
     * Collect multiple log entries, for multiple logs.
     * @summary Collect Multiple Logs
     * @param {LogManagementApiLogManagementCollectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCollect(requestParameters: LogManagementApiLogManagementCollectRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCollect(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect log entries from a log.
     * @summary Collect Log Entries
     * @param {LogManagementApiLogManagementCollectLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCollectLog(requestParameters: LogManagementApiLogManagementCollectLogRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCollectLog(requestParameters.logManagementCollectRequestCollectLogsInner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new log.
     * @summary Create Log
     * @param {LogManagementApiLogManagementCreateLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCreateLog(requestParameters: LogManagementApiLogManagementCreateLogRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCreateLog(requestParameters.logManagementCollectRequestCollectLogsInnerLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new log entry.
     * @summary Create Log Entry
     * @param {LogManagementApiLogManagementCreateLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCreateLogEntry(requestParameters: LogManagementApiLogManagementCreateLogEntryRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCreateLogEntry(requestParameters.logManagementCreateLogEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a log by identity.
     * @summary Delete Log
     * @param {LogManagementApiLogManagementDeleteLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementDeleteLog(requestParameters: LogManagementApiLogManagementDeleteLogRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementDeleteLog(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a log entry by identity.
     * @summary Delete Log Entry
     * @param {LogManagementApiLogManagementDeleteLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementDeleteLogEntry(requestParameters: LogManagementApiLogManagementDeleteLogEntryRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementDeleteLogEntry(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a log by its identity.
     * @summary Get Log
     * @param {LogManagementApiLogManagementGetLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLog(requestParameters: LogManagementApiLogManagementGetLogRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLog(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of logs.
     * @summary Get Log Collection
     * @param {LogManagementApiLogManagementGetLogCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogCollection(requestParameters: LogManagementApiLogManagementGetLogCollectionRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogCollection(requestParameters.page, requestParameters.itemsPerPage, requestParameters.levels, requestParameters.contains, requestParameters.from, requestParameters.to, requestParameters.order, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a log entry by its identity.
     * @summary Get Log Entry
     * @param {LogManagementApiLogManagementGetLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntry(requestParameters: LogManagementApiLogManagementGetLogEntryRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntry(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log entries.
     * @summary Get Log Entry Collection
     * @param {LogManagementApiLogManagementGetLogEntryCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryCollection(requestParameters: LogManagementApiLogManagementGetLogEntryCollectionRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryCollection(requestParameters.page, requestParameters.itemsPerPage, requestParameters.logIdentity, requestParameters.before, requestParameters.after, requestParameters.order, requestParameters.source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the frequency count of log entries.
     * @summary Get Log Entry Frequency Count
     * @param {LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log entry sources.
     * @summary Get Log Entry Source Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntrySourceCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntrySourceCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the frequency count of log entry sources.
     * @summary Get Log Entry Source Frequency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntrySourceFrequencyCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntrySourceFrequencyCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log entry tags.
     * @summary Get Log Entry Tag Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryTagCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryTagCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the distribution of log entry tags.
     * @summary Get Log Entry Tag Distribution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryTagDistributionCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryTagDistributionCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the frequency count of logs.
     * @summary Get Log Frequency Count
     * @param {LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the statistics of log levels.
     * @summary Get Log Level Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogLevelStatisticsCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogLevelStatisticsCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log namespaces.
     * @summary Get Log Namespace Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogNamespaceCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogNamespaceCollection(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharedApi - axios parameter creator
 * @export
 */
export const SharedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
         * @summary Retrieve the ping status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedApi - functional programming interface
 * @export
 */
export const SharedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
         * @summary Retrieve the ping status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ping200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharedApi - factory interface
 * @export
 */
export const SharedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedApiFp(configuration)
    return {
        /**
         * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
         * @summary Retrieve the ping status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: AxiosRequestConfig): AxiosPromise<Ping200Response> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharedApi - object-oriented interface
 * @export
 * @class SharedApi
 * @extends {BaseAPI}
 */
export class SharedApi extends BaseAPI {
    /**
     * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
     * @summary Retrieve the ping status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedApi
     */
    public ping(options?: AxiosRequestConfig) {
        return SharedApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


