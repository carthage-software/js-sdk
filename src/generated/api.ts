/* tslint:disable */
/* eslint-disable */
/**
 * Carthage API
 * The API Specification for Carthage
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface LogManagementCollect
 */
export interface LogManagementCollect {
    [key: string]: any;

    /**
     * 
     * @type {Array<LogManagementLogCollectLog>}
     * @memberof LogManagementCollect
     */
    'collect_logs': Array<LogManagementLogCollectLog>;
}
/**
 * 
 * @export
 * @interface LogManagementLogCollectLog
 */
export interface LogManagementLogCollectLog {
    /**
     * 
     * @type {LogManagementLogCreateLog}
     * @memberof LogManagementLogCollectLog
     */
    'log': LogManagementLogCreateLog;
    /**
     * 
     * @type {Array<LogManagementLogCollectLogEntry>}
     * @memberof LogManagementLogCollectLog
     */
    'entries': Array<LogManagementLogCollectLogEntry>;
}
/**
 * 
 * @export
 * @interface LogManagementLogCollectLogEntry
 */
export interface LogManagementLogCollectLogEntry {
    /**
     * The source of the entry, indicating what part of the system the entry is from.
     * @type {string}
     * @memberof LogManagementLogCollectLogEntry
     */
    'source': string;
    /**
     * The context of the entry, providing additional information to help understand the entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCollectLogEntry
     */
    'context': { [key: string]: any; };
    /**
     * The attributes of the entry, providing additional information not included in the main message.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCollectLogEntry
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LogManagementLogCollectLogEntry
     */
    'tags': Array<string>;
    /**
     * The timestamp indicating when the entry occurred.
     * @type {string}
     * @memberof LogManagementLogCollectLogEntry
     */
    'occurred_at': string;
}
/**
 * 
 * @export
 * @interface LogManagementLogCreateLog
 */
export interface LogManagementLogCreateLog {
    /**
     * The namespace associated with the log.
     * @type {string}
     * @memberof LogManagementLogCreateLog
     */
    'namespace': string;
    /**
     * The severity level of the log.
     * @type {number}
     * @memberof LogManagementLogCreateLog
     */
    'level': LogManagementLogCreateLogLevelEnum;
    /**
     * The template used for formatting the log message.
     * @type {string}
     * @memberof LogManagementLogCreateLog
     */
    'template': string;
}

export const LogManagementLogCreateLogLevelEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementLogCreateLogLevelEnum = typeof LogManagementLogCreateLogLevelEnum[keyof typeof LogManagementLogCreateLogLevelEnum];

/**
 * 
 * @export
 * @interface LogManagementLogCreateLogEntry
 */
export interface LogManagementLogCreateLogEntry {
    /**
     * The identity of the associated log.
     * @type {string}
     * @memberof LogManagementLogCreateLogEntry
     */
    'log_identity': string;
    /**
     * The source of the entry, indicating what part of the system the entry is from.
     * @type {string}
     * @memberof LogManagementLogCreateLogEntry
     */
    'source': string;
    /**
     * The context of the entry, providing additional information to help understand the entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCreateLogEntry
     */
    'context': { [key: string]: any; };
    /**
     * The attributes of the entry, providing additional information not included in the main message.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogCreateLogEntry
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LogManagementLogCreateLogEntry
     */
    'tags': Array<string>;
    /**
     * The timestamp indicating when the entry occurred.
     * @type {string}
     * @memberof LogManagementLogCreateLogEntry
     */
    'occurred_at': string;
}
/**
 * The order of the log entries.
 * @export
 * @enum {string}
 */

export const LogManagementLogLogEntryFilterOrder = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type LogManagementLogLogEntryFilterOrder = typeof LogManagementLogLogEntryFilterOrder[keyof typeof LogManagementLogLogEntryFilterOrder];


/**
 * Resource representing a log entry.
 * @export
 * @interface LogManagementLogLogEntryResource
 */
export interface LogManagementLogLogEntryResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'type': LogManagementLogLogEntryResourceTypeEnum;
    /**
     * Unique identity of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'identity': string;
    /**
     * Identity of the associated log.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'log_identity': string;
    /**
     * Source of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'source': string;
    /**
     * Contextual information for the log entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogLogEntryResource
     */
    'context': { [key: string]: any; };
    /**
     * Attributes associated with the log entry.
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementLogLogEntryResource
     */
    'attributes': { [key: string]: any; };
    /**
     * Tags associated with the log entry.
     * @type {Array<string>}
     * @memberof LogManagementLogLogEntryResource
     */
    'tags': Array<string>;
    /**
     * Timestamp when the log entry occurred.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'occurred_at': string;
    /**
     * Timestamp when the log entry was created.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'created_at': string;
    /**
     * Timestamp when the log entry was last updated.
     * @type {string}
     * @memberof LogManagementLogLogEntryResource
     */
    'updated_at': string;
}

export const LogManagementLogLogEntryResourceTypeEnum = {
    LogEntry: 'log_entry'
} as const;

export type LogManagementLogLogEntryResourceTypeEnum = typeof LogManagementLogLogEntryResourceTypeEnum[keyof typeof LogManagementLogLogEntryResourceTypeEnum];

/**
 * Paginated collection of LogEntryResource.
 * @export
 * @interface LogManagementLogLogEntryResourcePaginatedCollectionResource
 */
export interface LogManagementLogLogEntryResourcePaginatedCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'type': LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum;
    /**
     * Current page number.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'page': number;
    /**
     * Number of items per page.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'items_per_page': number;
    /**
     * Total number of items.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'total_items': number;
    /**
     * First item index.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'first': number;
    /**
     * Last item index.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'last': number;
    /**
     * Next page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'next'?: number | null;
    /**
     * Previous page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'previous'?: number | null;
    /**
     * Array of LogEntryResource.
     * @type {Array<LogManagementLogLogEntryResource>}
     * @memberof LogManagementLogLogEntryResourcePaginatedCollectionResource
     */
    'items': Array<LogManagementLogLogEntryResource>;
}

export const LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum = {
    PaginatedCollection: 'paginated_collection'
} as const;

export type LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum = typeof LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum[keyof typeof LogManagementLogLogEntryResourcePaginatedCollectionResourceTypeEnum];

/**
 * Resource representing a log entry source.
 * @export
 * @interface LogManagementLogLogEntrySourceResource
 */
export interface LogManagementLogLogEntrySourceResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogEntrySourceResource
     */
    'type': LogManagementLogLogEntrySourceResourceTypeEnum;
    /**
     * Source of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntrySourceResource
     */
    'source': string;
}

export const LogManagementLogLogEntrySourceResourceTypeEnum = {
    LogEntrySource: 'log_entry_source'
} as const;

export type LogManagementLogLogEntrySourceResourceTypeEnum = typeof LogManagementLogLogEntrySourceResourceTypeEnum[keyof typeof LogManagementLogLogEntrySourceResourceTypeEnum];

/**
 * Collection of LogEntrySourceResource.
 * @export
 * @interface LogManagementLogLogEntrySourceResourceCollectionResource
 */
export interface LogManagementLogLogEntrySourceResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogEntrySourceResourceCollectionResource
     */
    'type': LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntrySourceResource.
     * @type {Array<LogManagementLogLogEntrySourceResource>}
     * @memberof LogManagementLogLogEntrySourceResourceCollectionResource
     */
    'items': Array<LogManagementLogLogEntrySourceResource>;
}

export const LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum = typeof LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogLogEntrySourceResourceCollectionResourceTypeEnum];

/**
 * Resource representing a log entry tag.
 * @export
 * @interface LogManagementLogLogEntryTagResource
 */
export interface LogManagementLogLogEntryTagResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogEntryTagResource
     */
    'type': LogManagementLogLogEntryTagResourceTypeEnum;
    /**
     * Tag of the log entry.
     * @type {string}
     * @memberof LogManagementLogLogEntryTagResource
     */
    'tag': string;
}

export const LogManagementLogLogEntryTagResourceTypeEnum = {
    LogEntryTag: 'log_entry_tag'
} as const;

export type LogManagementLogLogEntryTagResourceTypeEnum = typeof LogManagementLogLogEntryTagResourceTypeEnum[keyof typeof LogManagementLogLogEntryTagResourceTypeEnum];

/**
 * Collection of LogEntryTagResource.
 * @export
 * @interface LogManagementLogLogEntryTagResourceCollectionResource
 */
export interface LogManagementLogLogEntryTagResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogEntryTagResourceCollectionResource
     */
    'type': LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntryTagResource.
     * @type {Array<LogManagementLogLogEntryTagResource>}
     * @memberof LogManagementLogLogEntryTagResourceCollectionResource
     */
    'items': Array<LogManagementLogLogEntryTagResource>;
}

export const LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum = typeof LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogLogEntryTagResourceCollectionResourceTypeEnum];

/**
 * The order of the logs.
 * @export
 * @enum {string}
 */

export const LogManagementLogLogFilterOrder = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type LogManagementLogLogFilterOrder = typeof LogManagementLogLogFilterOrder[keyof typeof LogManagementLogLogFilterOrder];


/**
 * The field to sort the logs by.
 * @export
 * @enum {string}
 */

export const LogManagementLogLogFilterSortBy = {
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    FirstEntryOccurredAt: 'firstEntryOccurredAt',
    LastEntryOccurredAt: 'lastEntryOccurredAt',
    Level: 'level'
} as const;

export type LogManagementLogLogFilterSortBy = typeof LogManagementLogLogFilterSortBy[keyof typeof LogManagementLogLogFilterSortBy];


/**
 * Resource representing a log namespace.
 * @export
 * @interface LogManagementLogLogNamespaceResource
 */
export interface LogManagementLogLogNamespaceResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogNamespaceResource
     */
    'type': LogManagementLogLogNamespaceResourceTypeEnum;
    /**
     * Namespace of the log.
     * @type {string}
     * @memberof LogManagementLogLogNamespaceResource
     */
    'namespace': string;
}

export const LogManagementLogLogNamespaceResourceTypeEnum = {
    LogNamespace: 'log_namespace'
} as const;

export type LogManagementLogLogNamespaceResourceTypeEnum = typeof LogManagementLogLogNamespaceResourceTypeEnum[keyof typeof LogManagementLogLogNamespaceResourceTypeEnum];

/**
 * Collection of LogNamespaceResource.
 * @export
 * @interface LogManagementLogLogNamespaceResourceCollectionResource
 */
export interface LogManagementLogLogNamespaceResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogNamespaceResourceCollectionResource
     */
    'type': LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum;
    /**
     * Array of LogNamespaceResource.
     * @type {Array<LogManagementLogLogNamespaceResource>}
     * @memberof LogManagementLogLogNamespaceResourceCollectionResource
     */
    'items': Array<LogManagementLogLogNamespaceResource>;
}

export const LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum = typeof LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogLogNamespaceResourceCollectionResourceTypeEnum];

/**
 * Resource representing a log.
 * @export
 * @interface LogManagementLogLogResource
 */
export interface LogManagementLogLogResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'type': LogManagementLogLogResourceTypeEnum;
    /**
     * Unique identity of the log.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'identity': string;
    /**
     * The namespace of the log.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'namespace': string;
    /**
     * 
     * @type {LogManagementLogLogResourceLevel}
     * @memberof LogManagementLogLogResource
     */
    'level': LogManagementLogLogResourceLevel;
    /**
     * The template for formatting the message.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'template': string;
    /**
     * Timestamp of the first entry occurrence, if available.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'first_entry_occurred_at'?: string | null;
    /**
     * Timestamp of the last entry occurrence, if available.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'last_entry_occurred_at'?: string | null;
    /**
     * Timestamp when the log was created.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'created_at': string;
    /**
     * Timestamp when the log was last updated.
     * @type {string}
     * @memberof LogManagementLogLogResource
     */
    'updated_at': string;
}

export const LogManagementLogLogResourceTypeEnum = {
    Log: 'log'
} as const;

export type LogManagementLogLogResourceTypeEnum = typeof LogManagementLogLogResourceTypeEnum[keyof typeof LogManagementLogLogResourceTypeEnum];

/**
 * The log level.
 * @export
 * @interface LogManagementLogLogResourceLevel
 */
export interface LogManagementLogLogResourceLevel {
    /**
     * Name of the log level.
     * @type {string}
     * @memberof LogManagementLogLogResourceLevel
     */
    'name': LogManagementLogLogResourceLevelNameEnum;
    /**
     * Value of the log level.
     * @type {number}
     * @memberof LogManagementLogLogResourceLevel
     */
    'value': LogManagementLogLogResourceLevelValueEnum;
}

export const LogManagementLogLogResourceLevelNameEnum = {
    Debug: 'Debug',
    Info: 'Info',
    Notice: 'Notice',
    Warning: 'Warning',
    Error: 'Error',
    Critical: 'Critical',
    Alert: 'Alert',
    Emergency: 'Emergency'
} as const;

export type LogManagementLogLogResourceLevelNameEnum = typeof LogManagementLogLogResourceLevelNameEnum[keyof typeof LogManagementLogLogResourceLevelNameEnum];
export const LogManagementLogLogResourceLevelValueEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementLogLogResourceLevelValueEnum = typeof LogManagementLogLogResourceLevelValueEnum[keyof typeof LogManagementLogLogResourceLevelValueEnum];

/**
 * Paginated collection of LogResource.
 * @export
 * @interface LogManagementLogLogResourcePaginatedCollectionResource
 */
export interface LogManagementLogLogResourcePaginatedCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'type': LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum;
    /**
     * Current page number.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'page': number;
    /**
     * Number of items per page.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'items_per_page': number;
    /**
     * Total number of items.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'total_items': number;
    /**
     * First item index.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'first': number;
    /**
     * Last item index.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'last': number;
    /**
     * Next page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'next'?: number | null;
    /**
     * Previous page number, if available.
     * @type {number}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'previous'?: number | null;
    /**
     * Array of LogResource.
     * @type {Array<LogManagementLogLogResource>}
     * @memberof LogManagementLogLogResourcePaginatedCollectionResource
     */
    'items': Array<LogManagementLogLogResource>;
}

export const LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum = {
    PaginatedCollection: 'paginated_collection'
} as const;

export type LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum = typeof LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum[keyof typeof LogManagementLogLogResourcePaginatedCollectionResourceTypeEnum];

/**
 * The frequency for log statistics, specifying how the data should be aggregated.
 * @export
 * @enum {string}
 */

export const LogManagementLogStatisticsFrequency = {
    Yearly: 'yearly',
    Quarterly: 'quarterly',
    Monthly: 'monthly',
    Weekly: 'weekly',
    Daily: 'daily',
    Hourly: 'hourly'
} as const;

export type LogManagementLogStatisticsFrequency = typeof LogManagementLogStatisticsFrequency[keyof typeof LogManagementLogStatisticsFrequency];


/**
 * Resource representing the frequency count of log entries.
 * @export
 * @interface LogManagementLogStatisticsLogEntryFrequencyCountResource
 */
export interface LogManagementLogStatisticsLogEntryFrequencyCountResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResource
     */
    'type': LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum;
    /**
     * Date associated with the frequency count.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResource
     */
    'date': string;
    /**
     * Count of log entries for the specified date.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResource
     */
    'count': number;
}

export const LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum = {
    LogEntryFrequencyCount: 'log_entry_frequency_count'
} as const;

export type LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceTypeEnum];

/**
 * Collection of LogEntryFrequencyCountResource.
 * @export
 * @interface LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntryFrequencyCountResource.
     * @type {Array<LogManagementLogStatisticsLogEntryFrequencyCountResource>}
     * @memberof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource
     */
    'items': Array<LogManagementLogStatisticsLogEntryFrequencyCountResource>;
}

export const LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResourceTypeEnum];

/**
 * Resource representing the frequency count of log entries by source.
 * @export
 * @interface LogManagementLogStatisticsLogEntrySourceFrequencyResource
 */
export interface LogManagementLogStatisticsLogEntrySourceFrequencyResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'type': LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum;
    /**
     * Source associated with the frequency count.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'source': string;
    /**
     * Count of log entries for the specified source.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'count': number;
    /**
     * Percentage of log entries for the specified source.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResource
     */
    'percentage': number;
}

export const LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum = {
    LogEntrySourceFrequency: 'log_entry_source_frequency'
} as const;

export type LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum = typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceTypeEnum];

/**
 * Collection of LogEntrySourceFrequencyResource.
 * @export
 * @interface LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntrySourceFrequencyResource.
     * @type {Array<LogManagementLogStatisticsLogEntrySourceFrequencyResource>}
     * @memberof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource
     */
    'items': Array<LogManagementLogStatisticsLogEntrySourceFrequencyResource>;
}

export const LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResourceTypeEnum];

/**
 * Resource representing the distribution of log entries by tag.
 * @export
 * @interface LogManagementLogStatisticsLogEntryTagDistributionResource
 */
export interface LogManagementLogStatisticsLogEntryTagDistributionResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResource
     */
    'type': LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum;
    /**
     * Tag associated with the distribution.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResource
     */
    'tag': string;
    /**
     * Count of log entries for the specified tag.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResource
     */
    'count': number;
}

export const LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum = {
    LogEntryTagDistribution: 'log_entry_tag_distribution'
} as const;

export type LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryTagDistributionResourceTypeEnum];

/**
 * Collection of LogEntryTagDistributionResource.
 * @export
 * @interface LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum;
    /**
     * Array of LogEntryTagDistributionResource.
     * @type {Array<LogManagementLogStatisticsLogEntryTagDistributionResource>}
     * @memberof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource
     */
    'items': Array<LogManagementLogStatisticsLogEntryTagDistributionResource>;
}

export const LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResourceTypeEnum];

/**
 * Resource representing the frequency count of logs.
 * @export
 * @interface LogManagementLogStatisticsLogFrequencyCountResource
 */
export interface LogManagementLogStatisticsLogFrequencyCountResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResource
     */
    'type': LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum;
    /**
     * Date associated with the frequency count.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResource
     */
    'date': string;
    /**
     * Count of logs for the specified date.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResource
     */
    'count': number;
}

export const LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum = {
    LogFrequencyCount: 'log_frequency_count'
} as const;

export type LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum = typeof LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogFrequencyCountResourceTypeEnum];

/**
 * Collection of LogFrequencyCountResource.
 * @export
 * @interface LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum;
    /**
     * Array of LogFrequencyCountResource.
     * @type {Array<LogManagementLogStatisticsLogFrequencyCountResource>}
     * @memberof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource
     */
    'items': Array<LogManagementLogStatisticsLogFrequencyCountResource>;
}

export const LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogFrequencyCountResourceCollectionResourceTypeEnum];

/**
 * Resource representing the statistics of logs by level.
 * @export
 * @interface LogManagementLogStatisticsLogLevelStatisticsResource
 */
export interface LogManagementLogStatisticsLogLevelStatisticsResource {
    /**
     * Type identifier for the resource.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'type': LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum;
    /**
     * 
     * @type {LogManagementLogStatisticsLogLevelStatisticsResourceLevel}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'level': LogManagementLogStatisticsLogLevelStatisticsResourceLevel;
    /**
     * Count of logs for the specified level.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'count': number;
    /**
     * Percentage of logs for the specified level.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResource
     */
    'percentage': number;
}

export const LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum = {
    LogLevelStatistics: 'log_level_statistics'
} as const;

export type LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum = typeof LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogLevelStatisticsResourceTypeEnum];

/**
 * Collection of LogLevelStatisticsResource.
 * @export
 * @interface LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource
 */
export interface LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource {
    /**
     * Type identifier for the collection.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource
     */
    'type': LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum;
    /**
     * Array of LogLevelStatisticsResource.
     * @type {Array<LogManagementLogStatisticsLogLevelStatisticsResource>}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource
     */
    'items': Array<LogManagementLogStatisticsLogLevelStatisticsResource>;
}

export const LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum = {
    SimpleCollection: 'simple_collection'
} as const;

export type LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum = typeof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum[keyof typeof LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResourceTypeEnum];

/**
 * Level associated with the statistics.
 * @export
 * @interface LogManagementLogStatisticsLogLevelStatisticsResourceLevel
 */
export interface LogManagementLogStatisticsLogLevelStatisticsResourceLevel {
    /**
     * Name of the level.
     * @type {string}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResourceLevel
     */
    'name': LogManagementLogStatisticsLogLevelStatisticsResourceLevelNameEnum;
    /**
     * Value of the level.
     * @type {number}
     * @memberof LogManagementLogStatisticsLogLevelStatisticsResourceLevel
     */
    'value': LogManagementLogStatisticsLogLevelStatisticsResourceLevelValueEnum;
}

export const LogManagementLogStatisticsLogLevelStatisticsResourceLevelNameEnum = {
    Debug: 'Debug',
    Info: 'Info',
    Notice: 'Notice',
    Warning: 'Warning',
    Error: 'Error',
    Critical: 'Critical',
    Alert: 'Alert',
    Emergency: 'Emergency'
} as const;

export type LogManagementLogStatisticsLogLevelStatisticsResourceLevelNameEnum = typeof LogManagementLogStatisticsLogLevelStatisticsResourceLevelNameEnum[keyof typeof LogManagementLogStatisticsLogLevelStatisticsResourceLevelNameEnum];
export const LogManagementLogStatisticsLogLevelStatisticsResourceLevelValueEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_250: 250,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_550: 550,
    NUMBER_600: 600
} as const;

export type LogManagementLogStatisticsLogLevelStatisticsResourceLevelValueEnum = typeof LogManagementLogStatisticsLogLevelStatisticsResourceLevelValueEnum[keyof typeof LogManagementLogStatisticsLogLevelStatisticsResourceLevelValueEnum];

/**
 * Resource representing the ping
 * @export
 * @interface SharedPingResource
 */
export interface SharedPingResource {
    /**
     * Type of the resource.
     * @type {string}
     * @memberof SharedPingResource
     */
    'type': SharedPingResourceTypeEnum;
    /**
     * A random quote from Hannibal, The Carthaginian General.
     * @type {string}
     * @memberof SharedPingResource
     */
    'quote'?: string;
    /**
     * The date and time
     * @type {string}
     * @memberof SharedPingResource
     */
    'time': string;
}

export const SharedPingResourceTypeEnum = {
    Ping: 'ping'
} as const;

export type SharedPingResourceTypeEnum = typeof SharedPingResourceTypeEnum[keyof typeof SharedPingResourceTypeEnum];


/**
 * LogManagementApi - axios parameter creator
 * @export
 */
export const LogManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Collect multiple log entries, for multiple logs.
         * @summary Collect Multiple Logs
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollect: async (requestBody?: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect log entries from a log.
         * @summary Collect Log Entries
         * @param {LogManagementLogCollectLog} [logManagementLogCollectLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollectLog: async (logManagementLogCollectLog?: LogManagementLogCollectLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logManagementLogCollectLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new log.
         * @summary Create Log
         * @param {LogManagementLogCreateLog} [logManagementLogCreateLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLog: async (logManagementLogCreateLog?: LogManagementLogCreateLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logManagementLogCreateLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new log entry.
         * @summary Create Log Entry
         * @param {LogManagementLogCreateLogEntry} [logManagementLogCreateLogEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLogEntry: async (logManagementLogCreateLogEntry?: LogManagementLogCreateLogEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logManagementLogCreateLogEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a log by identity.
         * @summary Delete Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLog: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementDeleteLog', 'identity', identity)
            const localVarPath = `/log-management/log/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a log entry by identity.
         * @summary Delete Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLogEntry: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementDeleteLogEntry', 'identity', identity)
            const localVarPath = `/log-management/log/entry/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a log by its identity.
         * @summary Get Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLog: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementGetLog', 'identity', identity)
            const localVarPath = `/log-management/log/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of logs.
         * @summary Get Log Collection
         * @param {string} [contains] 
         * @param {Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>} [levels] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {LogManagementLogLogFilterSortBy} [sortBy] 
         * @param {LogManagementLogLogFilterOrder} [order] 
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogCollection: async (contains?: string, levels?: Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>, from?: string, to?: string, sortBy?: LogManagementLogLogFilterSortBy, order?: LogManagementLogLogFilterOrder, page?: number, itemsPerPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (levels) {
                localVarQueryParameter['levels[]'] = levels;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['items_per_page'] = itemsPerPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a log entry by its identity.
         * @summary Get Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntry: async (identity: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('logManagementGetLogEntry', 'identity', identity)
            const localVarPath = `/log-management/log/entry/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log entries.
         * @summary Get Log Entry Collection
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {string} [logIdentity] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {LogManagementLogLogEntryFilterOrder} [order] 
         * @param {string} [source] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryCollection: async (page?: number, itemsPerPage?: number, logIdentity?: string, before?: string, after?: string, order?: LogManagementLogLogEntryFilterOrder, source?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['items_per_page'] = itemsPerPage;
            }

            if (logIdentity !== undefined) {
                localVarQueryParameter['log_identity'] = logIdentity;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any instanceof Date) ?
                    (after as any).toISOString() :
                    after;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the frequency count of log entries.
         * @summary Get Log Entry Frequency Count
         * @param {LogManagementLogStatisticsFrequency} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryFrequencyCountCollection: async (frequency: LogManagementLogStatisticsFrequency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'frequency' is not null or undefined
            assertParamExists('logManagementGetLogEntryFrequencyCountCollection', 'frequency', frequency)
            const localVarPath = `/log-management/log/statistic/entry-frequency-count/{frequency}`
                .replace(`{${"frequency"}}`, encodeURIComponent(String(frequency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log entry sources.
         * @summary Get Log Entry Source Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the frequency count of log entry sources.
         * @summary Get Log Entry Source Frequency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceFrequencyCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/statistic/entry-source-frequency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log entry tags.
         * @summary Get Log Entry Tag Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/entry/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the distribution of log entry tags.
         * @summary Get Log Entry Tag Distribution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagDistributionCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/statistic/entry-tag-distribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the frequency count of logs.
         * @summary Get Log Frequency Count
         * @param {LogManagementLogStatisticsFrequency} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogFrequencyCountCollection: async (frequency: LogManagementLogStatisticsFrequency, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'frequency' is not null or undefined
            assertParamExists('logManagementGetLogFrequencyCountCollection', 'frequency', frequency)
            const localVarPath = `/log-management/log/statistic/frequency-count/{frequency}`
                .replace(`{${"frequency"}}`, encodeURIComponent(String(frequency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the statistics of log levels.
         * @summary Get Log Level Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogLevelStatisticsCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/statistic/level-statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a collection of log namespaces.
         * @summary Get Log Namespace Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogNamespaceCollection: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log-management/log/namespace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogManagementApi - functional programming interface
 * @export
 */
export const LogManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Collect multiple log entries, for multiple logs.
         * @summary Collect Multiple Logs
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCollect(requestBody?: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCollect(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect log entries from a log.
         * @summary Collect Log Entries
         * @param {LogManagementLogCollectLog} [logManagementLogCollectLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCollectLog(logManagementLogCollectLog?: LogManagementLogCollectLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCollectLog(logManagementLogCollectLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new log.
         * @summary Create Log
         * @param {LogManagementLogCreateLog} [logManagementLogCreateLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCreateLog(logManagementLogCreateLog?: LogManagementLogCreateLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCreateLog(logManagementLogCreateLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new log entry.
         * @summary Create Log Entry
         * @param {LogManagementLogCreateLogEntry} [logManagementLogCreateLogEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementCreateLogEntry(logManagementLogCreateLogEntry?: LogManagementLogCreateLogEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogEntryResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementCreateLogEntry(logManagementLogCreateLogEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a log by identity.
         * @summary Delete Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementDeleteLog(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementDeleteLog(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a log entry by identity.
         * @summary Delete Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementDeleteLogEntry(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementDeleteLogEntry(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a log by its identity.
         * @summary Get Log
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLog(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLog(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of logs.
         * @summary Get Log Collection
         * @param {string} [contains] 
         * @param {Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>} [levels] 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {LogManagementLogLogFilterSortBy} [sortBy] 
         * @param {LogManagementLogLogFilterOrder} [order] 
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogCollection(contains?: string, levels?: Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>, from?: string, to?: string, sortBy?: LogManagementLogLogFilterSortBy, order?: LogManagementLogLogFilterOrder, page?: number, itemsPerPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogResourcePaginatedCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogCollection(contains, levels, from, to, sortBy, order, page, itemsPerPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a log entry by its identity.
         * @summary Get Log Entry
         * @param {string} identity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntry(identity: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogEntryResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntry(identity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log entries.
         * @summary Get Log Entry Collection
         * @param {number} [page] The page number for pagination. Defaults to 1.
         * @param {number} [itemsPerPage] The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
         * @param {string} [logIdentity] 
         * @param {string} [before] 
         * @param {string} [after] 
         * @param {LogManagementLogLogEntryFilterOrder} [order] 
         * @param {string} [source] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryCollection(page?: number, itemsPerPage?: number, logIdentity?: string, before?: string, after?: string, order?: LogManagementLogLogEntryFilterOrder, source?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogEntryResourcePaginatedCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryCollection(page, itemsPerPage, logIdentity, before, after, order, source, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the frequency count of log entries.
         * @summary Get Log Entry Frequency Count
         * @param {LogManagementLogStatisticsFrequency} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryFrequencyCountCollection(frequency: LogManagementLogStatisticsFrequency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryFrequencyCountCollection(frequency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log entry sources.
         * @summary Get Log Entry Source Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntrySourceCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogEntrySourceResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntrySourceCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the frequency count of log entry sources.
         * @summary Get Log Entry Source Frequency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntrySourceFrequencyCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntrySourceFrequencyCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log entry tags.
         * @summary Get Log Entry Tag Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryTagCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogEntryTagResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryTagCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the distribution of log entry tags.
         * @summary Get Log Entry Tag Distribution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogEntryTagDistributionCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogEntryTagDistributionCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the frequency count of logs.
         * @summary Get Log Frequency Count
         * @param {LogManagementLogStatisticsFrequency} frequency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogFrequencyCountCollection(frequency: LogManagementLogStatisticsFrequency, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogFrequencyCountCollection(frequency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the statistics of log levels.
         * @summary Get Log Level Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogLevelStatisticsCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogLevelStatisticsCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a collection of log namespaces.
         * @summary Get Log Namespace Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logManagementGetLogNamespaceCollection(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogManagementLogLogNamespaceResourceCollectionResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logManagementGetLogNamespaceCollection(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogManagementApi - factory interface
 * @export
 */
export const LogManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogManagementApiFp(configuration)
    return {
        /**
         * Collect multiple log entries, for multiple logs.
         * @summary Collect Multiple Logs
         * @param {LogManagementApiLogManagementCollectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollect(requestParameters: LogManagementApiLogManagementCollectRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementCollect(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect log entries from a log.
         * @summary Collect Log Entries
         * @param {LogManagementApiLogManagementCollectLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCollectLog(requestParameters: LogManagementApiLogManagementCollectLogRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementCollectLog(requestParameters.logManagementLogCollectLog, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new log.
         * @summary Create Log
         * @param {LogManagementApiLogManagementCreateLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLog(requestParameters: LogManagementApiLogManagementCreateLogRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogResource> {
            return localVarFp.logManagementCreateLog(requestParameters.logManagementLogCreateLog, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new log entry.
         * @summary Create Log Entry
         * @param {LogManagementApiLogManagementCreateLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementCreateLogEntry(requestParameters: LogManagementApiLogManagementCreateLogEntryRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogEntryResource> {
            return localVarFp.logManagementCreateLogEntry(requestParameters.logManagementLogCreateLogEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a log by identity.
         * @summary Delete Log
         * @param {LogManagementApiLogManagementDeleteLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLog(requestParameters: LogManagementApiLogManagementDeleteLogRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementDeleteLog(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a log entry by identity.
         * @summary Delete Log Entry
         * @param {LogManagementApiLogManagementDeleteLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementDeleteLogEntry(requestParameters: LogManagementApiLogManagementDeleteLogEntryRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logManagementDeleteLogEntry(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a log by its identity.
         * @summary Get Log
         * @param {LogManagementApiLogManagementGetLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLog(requestParameters: LogManagementApiLogManagementGetLogRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogResource> {
            return localVarFp.logManagementGetLog(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of logs.
         * @summary Get Log Collection
         * @param {LogManagementApiLogManagementGetLogCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogCollection(requestParameters: LogManagementApiLogManagementGetLogCollectionRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogResourcePaginatedCollectionResource> {
            return localVarFp.logManagementGetLogCollection(requestParameters.contains, requestParameters.levels, requestParameters.from, requestParameters.to, requestParameters.sortBy, requestParameters.order, requestParameters.page, requestParameters.itemsPerPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a log entry by its identity.
         * @summary Get Log Entry
         * @param {LogManagementApiLogManagementGetLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntry(requestParameters: LogManagementApiLogManagementGetLogEntryRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogEntryResource> {
            return localVarFp.logManagementGetLogEntry(requestParameters.identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log entries.
         * @summary Get Log Entry Collection
         * @param {LogManagementApiLogManagementGetLogEntryCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryCollection(requestParameters: LogManagementApiLogManagementGetLogEntryCollectionRequest = {}, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogEntryResourcePaginatedCollectionResource> {
            return localVarFp.logManagementGetLogEntryCollection(requestParameters.page, requestParameters.itemsPerPage, requestParameters.logIdentity, requestParameters.before, requestParameters.after, requestParameters.order, requestParameters.source, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the frequency count of log entries.
         * @summary Get Log Entry Frequency Count
         * @param {LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogStatisticsLogEntryFrequencyCountResourceCollectionResource> {
            return localVarFp.logManagementGetLogEntryFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log entry sources.
         * @summary Get Log Entry Source Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogEntrySourceResourceCollectionResource> {
            return localVarFp.logManagementGetLogEntrySourceCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the frequency count of log entry sources.
         * @summary Get Log Entry Source Frequency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntrySourceFrequencyCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementLogStatisticsLogEntrySourceFrequencyResourceCollectionResource> {
            return localVarFp.logManagementGetLogEntrySourceFrequencyCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log entry tags.
         * @summary Get Log Entry Tag Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogEntryTagResourceCollectionResource> {
            return localVarFp.logManagementGetLogEntryTagCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the distribution of log entry tags.
         * @summary Get Log Entry Tag Distribution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogEntryTagDistributionCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementLogStatisticsLogEntryTagDistributionResourceCollectionResource> {
            return localVarFp.logManagementGetLogEntryTagDistributionCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the frequency count of logs.
         * @summary Get Log Frequency Count
         * @param {LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<LogManagementLogStatisticsLogFrequencyCountResourceCollectionResource> {
            return localVarFp.logManagementGetLogFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the statistics of log levels.
         * @summary Get Log Level Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogLevelStatisticsCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementLogStatisticsLogLevelStatisticsResourceCollectionResource> {
            return localVarFp.logManagementGetLogLevelStatisticsCollection(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a collection of log namespaces.
         * @summary Get Log Namespace Collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logManagementGetLogNamespaceCollection(options?: AxiosRequestConfig): AxiosPromise<LogManagementLogLogNamespaceResourceCollectionResource> {
            return localVarFp.logManagementGetLogNamespaceCollection(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for logManagementCollect operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCollectRequest
 */
export interface LogManagementApiLogManagementCollectRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof LogManagementApiLogManagementCollect
     */
    readonly requestBody?: { [key: string]: any; }
}

/**
 * Request parameters for logManagementCollectLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCollectLogRequest
 */
export interface LogManagementApiLogManagementCollectLogRequest {
    /**
     * 
     * @type {LogManagementLogCollectLog}
     * @memberof LogManagementApiLogManagementCollectLog
     */
    readonly logManagementLogCollectLog?: LogManagementLogCollectLog
}

/**
 * Request parameters for logManagementCreateLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCreateLogRequest
 */
export interface LogManagementApiLogManagementCreateLogRequest {
    /**
     * 
     * @type {LogManagementLogCreateLog}
     * @memberof LogManagementApiLogManagementCreateLog
     */
    readonly logManagementLogCreateLog?: LogManagementLogCreateLog
}

/**
 * Request parameters for logManagementCreateLogEntry operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementCreateLogEntryRequest
 */
export interface LogManagementApiLogManagementCreateLogEntryRequest {
    /**
     * 
     * @type {LogManagementLogCreateLogEntry}
     * @memberof LogManagementApiLogManagementCreateLogEntry
     */
    readonly logManagementLogCreateLogEntry?: LogManagementLogCreateLogEntry
}

/**
 * Request parameters for logManagementDeleteLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementDeleteLogRequest
 */
export interface LogManagementApiLogManagementDeleteLogRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementDeleteLog
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementDeleteLogEntry operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementDeleteLogEntryRequest
 */
export interface LogManagementApiLogManagementDeleteLogEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementDeleteLogEntry
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementGetLog operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogRequest
 */
export interface LogManagementApiLogManagementGetLogRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLog
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementGetLogCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly contains?: string

    /**
     * 
     * @type {Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly levels?: Array<100 | 200 | 250 | 300 | 400 | 500 | 550 | 600>

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly from?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly to?: string

    /**
     * 
     * @type {LogManagementLogLogFilterSortBy}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly sortBy?: LogManagementLogLogFilterSortBy

    /**
     * 
     * @type {LogManagementLogLogFilterOrder}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly order?: LogManagementLogLogFilterOrder

    /**
     * The page number for pagination. Defaults to 1.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly page?: number

    /**
     * The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogCollection
     */
    readonly itemsPerPage?: number
}

/**
 * Request parameters for logManagementGetLogEntry operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogEntryRequest
 */
export interface LogManagementApiLogManagementGetLogEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntry
     */
    readonly identity: string
}

/**
 * Request parameters for logManagementGetLogEntryCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogEntryCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogEntryCollectionRequest {
    /**
     * The page number for pagination. Defaults to 1.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly page?: number

    /**
     * The number of items per page for pagination. Defaults to 20, with a maximum of 2000.
     * @type {number}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly itemsPerPage?: number

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly logIdentity?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly before?: string

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly after?: string

    /**
     * 
     * @type {LogManagementLogLogEntryFilterOrder}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly order?: LogManagementLogLogEntryFilterOrder

    /**
     * 
     * @type {string}
     * @memberof LogManagementApiLogManagementGetLogEntryCollection
     */
    readonly source?: string
}

/**
 * Request parameters for logManagementGetLogEntryFrequencyCountCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest {
    /**
     * 
     * @type {LogManagementLogStatisticsFrequency}
     * @memberof LogManagementApiLogManagementGetLogEntryFrequencyCountCollection
     */
    readonly frequency: LogManagementLogStatisticsFrequency
}

/**
 * Request parameters for logManagementGetLogFrequencyCountCollection operation in LogManagementApi.
 * @export
 * @interface LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest
 */
export interface LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest {
    /**
     * 
     * @type {LogManagementLogStatisticsFrequency}
     * @memberof LogManagementApiLogManagementGetLogFrequencyCountCollection
     */
    readonly frequency: LogManagementLogStatisticsFrequency
}

/**
 * LogManagementApi - object-oriented interface
 * @export
 * @class LogManagementApi
 * @extends {BaseAPI}
 */
export class LogManagementApi extends BaseAPI {
    /**
     * Collect multiple log entries, for multiple logs.
     * @summary Collect Multiple Logs
     * @param {LogManagementApiLogManagementCollectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCollect(requestParameters: LogManagementApiLogManagementCollectRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCollect(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect log entries from a log.
     * @summary Collect Log Entries
     * @param {LogManagementApiLogManagementCollectLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCollectLog(requestParameters: LogManagementApiLogManagementCollectLogRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCollectLog(requestParameters.logManagementLogCollectLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new log.
     * @summary Create Log
     * @param {LogManagementApiLogManagementCreateLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCreateLog(requestParameters: LogManagementApiLogManagementCreateLogRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCreateLog(requestParameters.logManagementLogCreateLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new log entry.
     * @summary Create Log Entry
     * @param {LogManagementApiLogManagementCreateLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementCreateLogEntry(requestParameters: LogManagementApiLogManagementCreateLogEntryRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementCreateLogEntry(requestParameters.logManagementLogCreateLogEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a log by identity.
     * @summary Delete Log
     * @param {LogManagementApiLogManagementDeleteLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementDeleteLog(requestParameters: LogManagementApiLogManagementDeleteLogRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementDeleteLog(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a log entry by identity.
     * @summary Delete Log Entry
     * @param {LogManagementApiLogManagementDeleteLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementDeleteLogEntry(requestParameters: LogManagementApiLogManagementDeleteLogEntryRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementDeleteLogEntry(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a log by its identity.
     * @summary Get Log
     * @param {LogManagementApiLogManagementGetLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLog(requestParameters: LogManagementApiLogManagementGetLogRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLog(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of logs.
     * @summary Get Log Collection
     * @param {LogManagementApiLogManagementGetLogCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogCollection(requestParameters: LogManagementApiLogManagementGetLogCollectionRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogCollection(requestParameters.contains, requestParameters.levels, requestParameters.from, requestParameters.to, requestParameters.sortBy, requestParameters.order, requestParameters.page, requestParameters.itemsPerPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a log entry by its identity.
     * @summary Get Log Entry
     * @param {LogManagementApiLogManagementGetLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntry(requestParameters: LogManagementApiLogManagementGetLogEntryRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntry(requestParameters.identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log entries.
     * @summary Get Log Entry Collection
     * @param {LogManagementApiLogManagementGetLogEntryCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryCollection(requestParameters: LogManagementApiLogManagementGetLogEntryCollectionRequest = {}, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryCollection(requestParameters.page, requestParameters.itemsPerPage, requestParameters.logIdentity, requestParameters.before, requestParameters.after, requestParameters.order, requestParameters.source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the frequency count of log entries.
     * @summary Get Log Entry Frequency Count
     * @param {LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogEntryFrequencyCountCollectionRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log entry sources.
     * @summary Get Log Entry Source Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntrySourceCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntrySourceCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the frequency count of log entry sources.
     * @summary Get Log Entry Source Frequency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntrySourceFrequencyCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntrySourceFrequencyCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log entry tags.
     * @summary Get Log Entry Tag Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryTagCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryTagCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the distribution of log entry tags.
     * @summary Get Log Entry Tag Distribution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogEntryTagDistributionCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogEntryTagDistributionCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the frequency count of logs.
     * @summary Get Log Frequency Count
     * @param {LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogFrequencyCountCollection(requestParameters: LogManagementApiLogManagementGetLogFrequencyCountCollectionRequest, options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogFrequencyCountCollection(requestParameters.frequency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the statistics of log levels.
     * @summary Get Log Level Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogLevelStatisticsCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogLevelStatisticsCollection(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a collection of log namespaces.
     * @summary Get Log Namespace Collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogManagementApi
     */
    public logManagementGetLogNamespaceCollection(options?: AxiosRequestConfig) {
        return LogManagementApiFp(this.configuration).logManagementGetLogNamespaceCollection(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SharedApi - axios parameter creator
 * @export
 */
export const SharedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
         * @summary Retrieve the ping status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharedApi - functional programming interface
 * @export
 */
export const SharedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SharedApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
         * @summary Retrieve the ping status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedPingResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SharedApi - factory interface
 * @export
 */
export const SharedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SharedApiFp(configuration)
    return {
        /**
         * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
         * @summary Retrieve the ping status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: AxiosRequestConfig): AxiosPromise<SharedPingResource> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SharedApi - object-oriented interface
 * @export
 * @class SharedApi
 * @extends {BaseAPI}
 */
export class SharedApi extends BaseAPI {
    /**
     * This endpoint is used to check the availability of the service. It returns a random quote from Hannibal, The Carthaginian General, along with the current time.
     * @summary Retrieve the ping status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharedApi
     */
    public ping(options?: AxiosRequestConfig) {
        return SharedApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}


